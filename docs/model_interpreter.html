<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>model_interpreter.model_interpreter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>model_interpreter.model_interpreter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import torch                            # PyTorch to create and apply deep learning models
from torch.autograd import Variable     # Create optimizable PyTorch variables
import pandas as pd                     # Pandas to handle the data in dataframes
import numpy as np                      # NumPy to handle numeric and NaN operations
import shap                             # Module used for the calculation of approximate Shapley values
import warnings                         # Print warnings for bad practices
from tqdm.auto import tqdm              # tqdm allows to track code execution progress
import time                             # Calculate code execution time
import plotly                           # Plotly for interactive and pretty plots
import plotly.graph_objs as go
import plotly.offline as py
import colorlover as cl                 # Get colors from colorscales
from functools import partial           # Enables using functions with some fixed parameters
import data_utils as du                 # Data science and machine learning relevant methods

# Constants
POS_COLOR = &#39;rgba(255,13,87,1)&#39;
NEG_COLOR = &#39;rgba(30,136,229,1)&#39;

# Auxiliary hidden methods
def calc_instance_score(model, sequence_data, instance, ref_output, x_length,
                        occlusion_wgt=0.7, id_column=0, inst_column=1):
    &#39;&#39;&#39;Calculate the instance importance score for a given instance.

    Parameters
    ----------
    model : nn.Module
        Machine learning model which will be interpreted.
    sequence_data : torch.Tensor
        Data corresponding to the data sequence to which the current instance
        belongs to.
    instance : int
        Number of the instance in the sequence. e.g. in a medical time series,
        the second clinical visit of a patient would be the instance number 1
        (counting starts at 0).
    ref_output : torch.Tensor
        Original model outputs of each instance in the sequence.
    x_length : int
        True sequence length, dismissing padding.
    occlusion_wgt : float, default 0.7
            Weight given to the occlusion part of the instance importance score.
            This scores is calculated as a weighted average of the instance&#39;s
            influence on the final output and the variation of the output
            probability, between the current instance and the previous one. As
            such, this weight should have a value between 0 and 1, with the
            output variation receiving the remaining weight (1 - occlusion_wgt),
            where 0 corresponds to not using the occlusion component at all, 0.5
            is a normal, unweighted average and 1 deactivates the use of the
            output variation part. If the value wasn&#39;t specified in the
            intepreter&#39;s initialization nor in the method argument, it will
            default to 0.7
    id_column : int, default 0
            Number of the column which corresponds to the subject identifier in
            the data tensor.
    inst_column : int, default 1
        Number of the column which corresponds to the instance or timestamp
        identifier in the data tensor.

    Returns
    -------
    inst_score : float
        Instance importance score calculated for the current instance, with the
        specified parameters.
    &#39;&#39;&#39;
    # Remove identifier columns from the data
    sequence_data = du.deep_learning.remove_tensor_column(sequence_data, [id_column, inst_column], inplace=True)
    # Indeces without the instance that is being analyzed
    instances_idx = list(range(sequence_data.shape[0]))
    instances_idx.remove(instance)
    # Sequence data without the instance that is being analyzed
    sequence_data = sequence_data[instances_idx, :]
    # Add a third dimension for the data to be readable by the model
    sequence_data = sequence_data.unsqueeze(0)
    # Update the sequence length as the instance is removed
    new_seq_length = x_length-1
    # Calculate the output without the instance that is being analyzed
    new_output = model(sequence_data[:, :new_seq_length, :])
    # Only use the last output (i.e. the one from the last instance of the sequence)
    new_output = new_output[new_seq_length-1].item()
    # Flag that indicates whether the output variation component will be used in the instance importance score
    # (in a weighted average)
    use_outvar_score = ref_output.shape[0] &gt; 1 and instance &gt; 0
    if use_outvar_score:
        # Get the output from the previous instance
        prev_output = ref_output[instance-1].item()
        # Get the output from the current instance
        curr_output = ref_output[instance].item()
    # Get the last output
    ref_output = ref_output[x_length-1].item()
    # The instance importance score is then the difference between the output probability with the instance
    # and the probability without the instance
    inst_score = ref_output - new_output
    if instance &gt; 0 and use_outvar_score:
        # If it&#39;s not the first instance, add the output variation characteristic in a weighted average
        inst_score = occlusion_wgt * inst_score + (1 - occlusion_wgt) * (curr_output - prev_output)
    # Apply a tanh function to make even the smaller scores (which are the most frequent) more salient
    inst_score = np.tanh(4 * inst_score)
    return inst_score

class KernelFunction:
    def __init__(self, model, model_type=&#39;multivariate_rnn&#39;):
        # Save the model object to be used in the main function
        self.model = model
        # Log the model type
        model_type = model_type.lower()
        if model_type == &#39;multivariate_rnn&#39; or model_type == &#39;mlp&#39;:
            self.model_type = model_type
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {model_type}.&#39;)

    def f(self, data, hidden_state=None):
        &#39;&#39;&#39;Function that will be used in the SHAP kernel explainer, converting
        a NumPy array into the model&#39;s output.

        Parameters
        ----------
        data : numpy.ndarray
            Data corresponding to a single instance (or timestamp, in a time
            series) used in the SHAP kernel explainer.
        hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
            Hidden state coming from the previous recurrent cell. If none is
            specified, the hidden state is initialized as zero.

        Returns
        -------
        output : numpy.ndarray
            Output of the model obtained with the given instance data and
            possible hidden state.
        &#39;&#39;&#39;
        if isinstance(data, np.ndarray):
            # Make sure the data is of type float
            data = torch.from_numpy(data).float()
        # Calculate the output
        if self.model_type == &#39;multivariate_rnn&#39;:
            if len(data.shape) &lt; 3:
                data = data.unsqueeze(0)
            output = self.model(data, hidden_state=hidden_state)
        elif self.model_type == &#39;mlp&#39;:
            output = self.model(data)
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {self.model_type}.&#39;)
        if torch.cuda.is_available():
            return output.detach().cpu().numpy()
        else:
            return output.detach().numpy()

class ModelInterpreter:
    &#39;&#39;&#39;A machine learning model interpreter which calculates instance and
    feature importance.

    The current focus of the class is to analyze neural networks built in
    the PyTorch framework, which classify sequential data with potentially
    variable sequence length.

    Parameters
    ----------
    model : nn.Module
        Machine learning model which will be interpreted.
    data : torch.Tensor or pandas.DataFrame, default None
        Data used in the interpretation, either directly by analyzing the
        outputs obtained with each sample or indireclty by using as
        background data in methods such as SHAP explainers. The data will be
        used in PyTorch tensor format, but the user can submit it as a
        pandas dataframe, which is then automatically padded and converted.
    labels : torch.Tensor, default None
        Labels corresponding to the data used, either specified in the input
        or all the data that the interpreter has.
    model_type : string, default &#39;multivariate_rnn&#39;
        Sets the type of machine learning model. Important to know what type
        of inference and data processing to do. Currently available options
        are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
    is_custom : bool, default False
        If set to True, the method will assume that the model being used is a
        custom built one, which won&#39;t require sequence length information during
        the feedforward process.
    already_embedded : bool, default False
        If set to True, it means that the categorical features are already
        embedded when fetching a batch, i.e. there&#39;s no need to run the embedding
        layer(s) during the model&#39;s feedforward.
    seq_len_dict : dict, default None
        Dictionary containing the sequence lengths for each index of the
        original dataframe. This allows to ignore the padding done in
        the fixed sequence length tensor.
    id_column_num : int, default None
        Number of the column which corresponds to the subject identifier in
        the data tensor.
    id_column_name : string, default None
        Name of the column which corresponds to the subject identifier in
        the data tensor.
    inst_column_num : int, default None
        Number of the column which corresponds to the instance or timestamp
        identifier in the data tensor.
    inst_column_name : string, default None
        Name of the column which corresponds to the instance or timestamp
        identifier in the data tensor.
    label_column_num : int, default None
        Number of the column which corresponds to the label in the data
        tensor. Only needed if the data is in dataframe format.
    label_column_name : string, default None
        Name of the column which corresponds to the label in the data
        tensor. Only needed if the data is in dataframe format.
    fast_calc : bool, default True
        If set to True, the algorithm uses less background samples (SHAP)
        or optimization steps (mask filter), in order to do a fast
        interpretation of the model. If set to False, the process takes
        more time in order to get a more precise and truthful
        interpretation of the model&#39;s behavior, requiring longer
        computation times.
    SHAP_bkgnd_samples : int, default &#39;auto&#39;
        Number of samples to use as background data, in case a SHAP
        explainer is applied (fast_calc must be set to False).
    random_seed : integer, default 42
        Seed used when shuffling the data.
    feat_names : list of string, default None
        Column names of the dataframe associated to the data. If no list is
        provided, the dataframe should be given in the data argument, so as
        to fetch the names of the columns.
    padding_value : numeric
        Value to use in the padding, to fill the sequences.
    occlusion_wgt : float, default 0.7
        Weight given to the occlusion part of the instance importance score.
        This scores is calculated as a weighted average of the instance&#39;s
        influence on the final output and the variation of the output
        probability, between the current instance and the previous one. As
        such, this weight should have a value between 0 and 1, with the
        output variation receiving the remaining weight (1 - occlusion_wgt),
        where 0 corresponds to not using the occlusion component at all, 0.5
        is a normal, unweighted average and 1 deactivates the use of the
        output variation part.
    total_length : int, default None
        If not None, the feature importance scores will be padded to have
        length total_length.
    &#39;&#39;&#39;
    def __init__(self, model, data=None, labels=None, model_type=&#39;multivariate_rnn&#39;,
                 is_custom=False, already_embedded=False, seq_len_dict=None,
                 id_column_num=None, id_column_name=None, inst_column_num=None,
                 inst_column_name=None, label_column_num=None, label_column_name=None,
                 fast_calc=True, SHAP_bkgnd_samples=&#39;auto&#39;, random_seed=42,
                 feat_names=None, padding_value=999999, occlusion_wgt=0.7,
                 total_length=None):
        # Initialize parameters according to user input
        self.model = model
        self.data = data
        self.seq_len_dict = seq_len_dict
        self.id_column_num = id_column_num
        self.id_column_name = id_column_name
        self.inst_column_num = inst_column_num
        self.inst_column_name = inst_column_name
        self.label_column_num = label_column_num
        self.label_column_name = label_column_name
        self.fast_calc = fast_calc
        self.SHAP_bkgnd_samples = SHAP_bkgnd_samples
        self.random_seed = random_seed
        self.feat_names = feat_names
        self.padding_value = padding_value
        self.occlusion_wgt = occlusion_wgt
        self.total_length = total_length
        if model_type == &#39;multivariate_rnn&#39; or model_type == &#39;mlp&#39;:
            self.model_type = model_type
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {model_type}.&#39;)
        self.is_custom = is_custom
        self.already_embedded = already_embedded

        # Put the model in evaluation mode to deactivate dropout
        self.model.eval()

        if data is not None:
            if type(data) is torch.Tensor:
                self.data = data
                self.labels = labels
                if model_type == &#39;mlp&#39;:
                    self.data = du.deep_learning.remove_tensor_column(data, id_column, inplace=True)
            elif type(data) is np.ndarray:
                # Convert from numpy to pytorch
                self.data = torch.from_numpy(data)
                self.labels = torch.from_numpy(labels)
                if model_type == &#39;mlp&#39;:
                    self.data = du.deep_learning.remove_tensor_column(data, id_column, inplace=True)
            elif type(data) is pd.DataFrame:
                # Fetch the column names, ignoring the ID column
                self.feat_names = list(data.columns)
                if self.id_column_num is None and self.id_column_name is not None:
                    # Find the ID column number
                    self.id_column_num = du.search_explore.find_col_idx(data, self.id_column_name)
                elif self.id_column_num is not None and self.id_column_name is None:
                    # Convert the ID column index to the column name
                    self.id_column_name = self.feat_names[self.id_column_num]
                if self.inst_column_num is None and self.inst_column_name is not None:
                    # Find the instance column number
                    self.inst_column_num = du.search_explore.find_col_idx(data, self.inst_column_name)
                elif self.inst_column_num is not None and self.inst_column_name is None:
                    # Convert the instance column index to the column name
                    self.inst_column_name = self.feat_names[self.inst_column_num]
                if self.total_length is None:
                    # Find the maximum sequence length, so that the ML models and their related methods can handle all sequences, which have varying sequence lengths
                    self.total_length = data.groupby(self.id_column_name)[self.inst_column_name].count().max()
                if self.label_column_num is None:
                    if self.label_column_name is not None:
                        # Find the instance column number
                        self.label_column_num = du.search_explore.find_col_idx(data, self.label_column_name)
                    else:
                        # Counter that indicates in which column we&#39;re in when searching for the label column
                        col_num = 0
                        for col in data.columns:
                            if &#39;label&#39; in col:
                                # Column name corresponding to the label
                                self.label_column_name = col
                                # Column number corresponding to the label
                                self.label_column_num = col_num
                                break
                            col_num += 1
                if self.label_column_name is None:
                    self.label_column_name = self.feat_names[self.label_column_num]
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=[self.id_column_name,
                                                                       self.label_column_name],
                                                            update_idx=False)
                # Fetch the column numbers, ignoring the ID column
                self.feat_num = list(range(len(data.columns)))
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.id_column_num,
                                                          update_idx=False)
                # Also update the idx when removing the label, since the features
                # tensors aren&#39;t going to contain the label
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.label_column_num,
                                                          update_idx=True)
                if self.model_type == &#39;multivariate_rnn&#39;:
                    # Also ignore the instance ID column
                    self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                                to_remove=self.inst_column_name,
                                                                update_idx=False)
                    self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                              to_remove=self.inst_column_num,
                                                              update_idx=False)
                    # Find the sequence lengths of the data
                    self.seq_len_dict = du.padding.get_sequence_length_dict(data, id_column=self.id_column_name, ts_column=self.inst_column_name)
                    # Pad data (to have fixed sequence length) and convert into a PyTorch tensor
                    data_tensor = du.padding.dataframe_to_padded_tensor(data, seq_len_dict=self.seq_len_dict, id_column=self.id_column_name,
                                                                        ts_column=self.inst_column_name, padding_value=padding_value,
                                                                        label_column=self.label_column_name, total_length=self.total_length,
                                                                        inplace=True)
                    # Separate labels from features
                    dataset = du.datasets.Time_Series_Dataset(data, data_tensor,
                                                              seq_len_dict=self.seq_len_dict,
                                                              label_name=self.label_column_name)
                elif self.model_type == &#39;mlp&#39;:
                    # Convert into a PyTorch tensor
                    data_tensor = torch.from_numpy(data.numpy())
                    # Separate labels from features
                    dataset = du.datasets.Tabular_Dataset(data_tensor, data)

                self.data = dataset.X
                self.labels = dataset.y
            else:
                raise Exception(&#39;ERROR: Invalid data type. Please provide data in a Pandas DataFrame, PyTorch Tensor or NumPy Array format.&#39;)
        else:
            # Convert the column indeces to the column names
            if self.id_column_num is None and self.id_column_name is not None:
                # Find the ID column number
                self.id_column_num = self.feat_names.index(self.id_column_name)
            elif self.id_column_num is not None and self.id_column_name is None:
                # Convert the ID column index to the column name
                self.id_column_name = self.feat_names[self.id_column_num]
            if self.inst_column_num is None and self.inst_column_name is not None:
                # Find the instance column number
                self.inst_column_num =  self.feat_names.index(self.inst_column_name)
            elif self.inst_column_num is not None and self.inst_column_name is None:
                # Convert the instance column index to the column name
                self.inst_column_name = self.feat_names[self.inst_column_num]
            if self.label_column_num is None and self.label_column_name is not None:
                # Find the label column number
                self.label_column_num =  self.feat_names.index(self.label_column_name)
            elif self.label_column_num is not None and self.label_column_name is None:
                # Convert the label column index to the column name
                self.label_column_name = self.feat_names[self.label_column_num]
            # Fetch the column numbers, ignoring the ID column
            self.feat_num = list(range(len(self.feat_names)))
            self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                      to_remove=self.id_column_num,
                                                      update_idx=False)
            self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                        to_remove=self.id_column_name,
                                                        update_idx=False)
            if self.label_column_num is not None:
                # Also update the idx when removing the label, since the features
                # tensors aren&#39;t going to contain the label
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=self.label_column_name,
                                                            update_idx=False)
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                        to_remove=self.label_column_num,
                                                        update_idx=True)
            if self.model_type == &#39;multivariate_rnn&#39;:
                # Also ignore the instance ID column
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=self.inst_column_name,
                                                            update_idx=False)
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.inst_column_num,
                                                          update_idx=False)

        # Declare explainer attribute which will store the SHAP Explainer object
        self.explainer = None
        # Declare attributes that will store importance scores (instance and feature importance)
        self.inst_scores = None
        self.feat_scores = None

    def create_bkgnd_test_sets(self, shuffle_dataset=True):
        &#39;&#39;&#39;Distributes the data into background and test sets and returns
        the respective data tensors.

        Parameters
        ----------
        random_seed : integer, default 42
            Seed used when shuffling the data.
        shuffle_dataset : bool, default True
            If set to True, the data of which set is shuffled.

        Returns
        -------
        bkgnd_data : torch.Tensor, default None
            Background data used in the SHAP explainer to estimate conditional
            expectations.
        test_data : torch.Tensor, default None
            A subset of data on which model interpretation will be made (i.e.
            calculating feature and/or instance importance).
        &#39;&#39;&#39;
        # Create data indices for training and test splits
        dataset_size = self.data.shape[0]
        indices = list(range(dataset_size))
        if shuffle_dataset:
            # Shuffle data
            np.random.seed(self.random_seed)
            np.random.shuffle(indices)
        bkgnd_indices, test_indices = indices[:self.SHAP_bkgnd_samples], indices[self.SHAP_bkgnd_samples:]

        # Get separate tensors for the background data and the test data
        bkgnd_data = self.data[bkgnd_indices]
        test_data = self.data[test_indices]
        return bkgnd_data, test_data

    def mask_filter_step(self, mask, data, ref_output, l1_coeff=1,
                         hidden_state=None, debug_loss=False):
        &#39;&#39;&#39;Perform a single optimization step to calculate a new version of the
        mask filter.

        Parameters
        ----------
        mask : numpy.Array
            Current mask filter, either the initial one or from the previous
            optimization iteration.
        data : torch.Tensor
            Data sample which will be used to determine the most relevant
            features. In case of multivariate sequential data, this must be a
            single instance of a sequence.
        ref_output : torch.Tensor or float
            Model&#39;s output to the original instance, with no mask filters applied.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
            Hidden state coming from the previous recurrent cell. If none is
            specified, the hidden state is initialized as zero.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            optimization loss.

        Returns
        -------
        mask : numpy.Array
            Current mask filter, after the performed optimization step.

        if debug_loss is True:

        loss : float
            Current loss value of the mask filter optimization.
        &#39;&#39;&#39;
        # Get the model&#39;s output for the masked input data
        new_output = self.model((mask * data).unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
        # Calculate the loss function
        # • Minimize the number of activated mask filter units (occluded features)
        # • Maximize the change made to the output
        loss = l1_coeff * torch.mean(torch.abs(1 - mask)) + 1 - (ref_output - new_output).pow(2)
        # Backpropagate the loss function and run an optimization step (update the mask filter)
        loss.backward(retain_graph=True)
        mask.grad = du.deep_learning.change_grad((-1) * mask.grad, mask.data)
        mask.data = mask.data + mask.grad
        # Make sure that the mask has values either 0 or 1
        mask.data.clamp_(0, 1)
        mask.data.round_()
        if debug_loss:
            return mask, loss.item()
        else:
            return mask

    # [TODO] Confirm that the mask filter is working in every scenario
    def mask_filter(self, data=None, x_lengths=None, max_iter=100, l1_coeff=1,
                    lr=0.001, recur_layer=None, see_progress=True, debug_loss=False):
        &#39;&#39;&#39;Calculate a mask filter for the given data samples, through an
        appropriate optimization.

        Parameters
        ----------
        data : torch.Tensor, default None
            Data sample(s) which will be used to determine the most relevant
            features. In case of multivariate sequential data, each instance will
            be analyzed seperately. If None, all data known to the model
            interpreter will be used.
        x_lengths : list of int
            Sorted list of sequence lengths, relative to the input data.
        max_iter : int, default 100
            Maximum number of iterations of the mask filter optimization, for
            each instance.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        lr : float, default 0.001
            Learning rate used in the optimization algorithm.
        recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
            Pointer to the recurrent layer in the model, if it exists. It should
            either be a LSTM, GRU or RNN network. If none is specified, the
            method will automatically search for a recurrent layer in the model.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the feature importance scores calculations.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            optimization loss.

        Returns
        -------
        mask : numpy.Array
            Output mask, after finishing the optimization for every specified
            sample. It will be inverted before returning, so as to be an array
            filled with zeros, except in the indeces corresponding to the most
            relevant features, where it will be one.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        # [TODO] Work on an option to use input data different from multivariate sequential
        if data is None:
            # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
            data = self.data
        if x_lengths is None:
            # Sort the data by sequence length
            data, x_lengths = du.padding.sort_by_seq_len(data, self.seq_len_dict)
        if len(data.shape) &gt; 1 and recur_layer is None:
            # Search for a recurrent layer
            if hasattr(self.model, &#39;lstm&#39;):
                recur_layer = self.model.lstm
            elif hasattr(self.model, &#39;gru&#39;):
                recur_layer = self.model.gru
            elif hasattr(self.model, &#39;rnn&#39;):
                recur_layer = self.model.rnn
            else:
                raise Exception(&#39;ERROR: No recurrent layer found. Please specify it in the recur_layer argument.&#39;)

        # Confirm that the model is in evaluation mode to deactivate dropout
        self.model.eval()
        # Create a mask filter variable, initialized as an all ones tensor
        mask = torch.ones(data.shape)
        # [DEBUG] Create a loss matrix to analyse the convergence of mask filter optimizations
        loss_mtx = []

        if len(data.shape) == 3:
            # Loop to go through each sequence in the input data
            for seq in tqdm(range(data.shape[0]), disable=not see_progress):
                # Get the true length of the current sequence
                seq_len = x_lengths[seq]
                # Loop to go through each instance in the input sequence
                for inst in tqdm(range(seq_len), disable=not see_progress):
                    hidden_state = None
                    # Get the hidden state that the model receives as an input
                    if inst &gt; 0:
                        # Get the hidden state outputed from the previous recurrent cell
                        _, hidden_state = recur_layer(data[:inst])
                        # Avoid backpropagating through previous instances
                        if type(hidden_state) is tuple:
                            hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                        else:
                            hidden_state.detach_()
                    # Temporary mask filter for he current instance
                    tmp_mask = Variable(mask[seq, inst, :], requires_grad=True)
                    # [DEBUG] List of the current optimization&#39;s losses
                    tmp_loss_list = []
                    # Mask filter optimization loop
                    for iter in tqdm(range(max_iter), disable=not see_progress):
                        # Calculate the model&#39;s output to the original, unchanged instance data
                        ref_output = self.model(data[seq, inst, :].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                        # Prevent mask filter optimization from backpropagating through the reference output
                        ref_output.detach_()
                        # Perform a single optimization step
                        tmp_mask, tmp_loss = self.mask_filter_step(tmp_mask, data[seq, inst, :], ref_output, l1_coeff, hidden_state, debug_loss=debug_loss)
                        tmp_loss_list.append(tmp_loss)
                    # Save the optimized mask filter of the current instance
                    mask[seq, inst, :] = tmp_mask
                    # [DEBUG] Add the current instance&#39;s optimization logs to the overall loss matrix
                    loss_mtx.append(tmp_loss_list)

        elif len(data.shape) == 2:
            # Loop to go through each instance in the input sequence
            for inst in tqdm(range(data.shape[0]), disable=not see_progress):
                hidden_state = None
                # Get the hidden state that the model receives as an input
                if inst &gt; 0:
                    # Get the hidden state outputed from the previous recurrent cell
                    _, hidden_state = recur_layer(data[:inst])
                    # Avoid backpropagating through previous instances
                    if type(hidden_state) is tuple:
                        hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                    else:
                        hidden_state.detach_()
                # Temporary mask filter for he current instance
                tmp_mask = Variable(mask[inst], requires_grad=True)
                # Mask filter optimization loop
                for iter in tqdm(range(max_iter), disable=not see_progress):
                    # Calculate the model&#39;s output to the original, unchanged instance data
                    ref_output = self.model(data[inst].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                    # Prevent mask filter optimization from backpropagating through the reference output
                    ref_output.detach_()
                    # Perform a single optimization step
                    tmp_mask = self.mask_filter_step(tmp_mask, data[inst], ref_output, l1_coeff, hidden_state)
                # Save the optimized mask filter of the current instance
                mask[inst] = tmp_mask

        elif len(data.shape) == 1:
            # Make sure that the mask can be optimized properly
            mask.requires_grad_()
            # Mask filter optimization loop
            for iter in tqdm(range(max_iter), disable=not see_progress):
                # Calculate the model&#39;s output to the original, unchanged instance data
                ref_output = self.model(data.unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                # Prevent mask filter optimization from backpropagating through the reference output
                ref_output.detach_()
                # Perform a single optimization step
                mask = self.mask_filter_step(mask, data, ref_output, l1_coeff)

        else:
            raise Exception(f&#39;ERROR: Can\&#39;t handle data with more than 3 dimensions. Submitted data with {len(data.shape)} dimensions.&#39;)

        # Return the inverted version of the mask, to atrribute 1 (one) to the most relevant features
        if debug_loss:
            return 1 - mask, loss_mtx
        else:
            return 1 - mask

    def instance_importance(self, data=None, labels=None, x_lengths=None,
                            see_progress=True, occlusion_wgt=0.7):
        &#39;&#39;&#39;Calculate the instance importance scores to interpret the impact of
        each instance of a sequence on the final output.

        Parameters
        ----------
        data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance). Otherwise, all the data is used.
        labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        x_lengths : list of int
            Sorted list of sequence lengths, relative to the input data.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the instance importance scores calculations.
        occlusion_wgt : float, default 0.7
            Weight given to the occlusion part of the instance importance score.
            This scores is calculated as a weighted average of the instance&#39;s
            influence on the final output and the variation of the output
            probability, between the current instance and the previous one. As
            such, this weight should have a value between 0 and 1, with the
            output variation receiving the remaining weight (1 - occlusion_wgt),
            where 0 corresponds to not using the occlusion component at all, 0.5
            is a normal, unweighted average and 1 deactivates the use of the
            output variation part. If the value wasn&#39;t specified in the
            intepreter&#39;s initialization nor in the method argument, it will
            default to 0.7

        Returns
        -------
        inst_scores : numpy.Array
            Array containing the importance scores of each instance in the
            given input sequences.
        &#39;&#39;&#39;
        if occlusion_wgt is None:
            if self.occlusion_wgt is not None:
                # Set to the class&#39;s occlusion weight value
                occlusion_wgt = self.occlusion_wgt
            else:
                # Set the occlusion weight value to 0.7 (default)
                occlusion_wgt = 0.7
                self.occlusion_wgt = occlusion_wgt

        # Confirm that the occlusion weight has a valid value (between 0 and 1)
        if occlusion_wgt &gt; 1 or occlusion_wgt &lt; 0:
            raise Exception(f&#39;ERROR: Inserted invalid occlusion weight value {occlusion_wgt}. Please replace with a value between 0 and 1.&#39;)

        if occlusion_wgt &lt; 1:
            # If the output variation is used in the calculation of the score,
            # get the reference outputs for all the instances of the sequences
            seq_final_outputs = False
        else:
            # Otherwise, only the final outputs of the sequences are retrieved
            seq_final_outputs = True

        if data is None:
            # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
            data = self.data
            labels = self.labels
        # Make sure that the data is in type float
        data = data.float()
        # Model output when using all the original instances in the input sequences
        ref_output, _ = du.deep_learning.model_inference(self.model, data=(data, labels),
                                                         metrics=[&#39;&#39;], model_type=self.model_type,
                                                         is_custom=self.is_custom,
                                                         seq_len_dict=self.seq_len_dict,
                                                         padding_value=self.padding_value,
                                                         seq_final_outputs=seq_final_outputs,
                                                         cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                         already_embedded=self.already_embedded)

        if not seq_final_outputs:
            # Cumulative sequence lengths (true end of the sequences)
            final_seq_idx = np.cumsum(x_lengths)
            start_idx = np.roll(final_seq_idx, 1)
            start_idx[0] = 0
            ref_output = [ref_output[start_idx[i]:final_seq_idx[i]] for i in range(len(start_idx))]

        inst_scores = [[calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
                                            x_lengths[seq_num], occlusion_wgt, self.id_column_num,
                                            self.inst_column_num)
                        for inst in range(x_lengths[seq_num])] for seq_num in tqdm(range(data.shape[0]), disable=not see_progress)]
        # DEBUG
        # inst_scores = []
        # for seq_num in tqdm(range(data.shape[0]), disable=not see_progress):
        #     tmp_list = []
        #     for inst in range(x_lengths[seq_num]):
        #         tmp_list.append(calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
        #                                             x_lengths[seq_num], occlusion_wgt, self.id_column_num, self.inst_column_num))
        #     inst_scores.append(tmp_list)

        # Pad the instance scores lists so that all have the same length
        inst_scores = [du.padding.pad_list(scores_list, data.shape[1], padding_value=self.padding_value)
                       for scores_list in inst_scores]
        # Convert to a NumPy array
        inst_scores = np.array(inst_scores)
        return inst_scores

    def feature_importance(self, test_data=None, model_type=None,
                           method=&#39;shap&#39;, fast_calc=None, see_progress=True,
                           bkgnd_data=None, max_iter=100, l1_coeff=0, lr=0.001,
                           recur_layer=None, create_new_explainer=True, debug_loss=False,
                           total_length=None):
        &#39;&#39;&#39;Calculate the feature importance scores to interpret the impact
        of each feature in each instance&#39;s output.

        Parameters
        ----------
        test_data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance). Otherwise, all the data is used.
        model_type : string, default &#39;multivariate_rnn&#39;
            Sets the type of machine learning model. Important to know what type
            of inference and data processing to do. Currently available options
            are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
        method : string, defautl SHAP
            Defines which interpretability technique to use. Current options
            include SHAP Kernel Explainer (default) and mask filter.
        fast_calc : bool, default None
            If set to True, the algorithm uses less background samples (SHAP)
            or optimization steps (mask filter), in order to do a fast
            interpretation of the model. If set to False, the process takes
            more time in order to get a more precise and truthful
            interpretation of the model&#39;s behavior, requiring longer
            computation times.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the feature importance scores calculations.
        total_length : int, default None
            If not None, the feature importance scores will be padded to have
            length total_length.

        if fast_calc is False:

        bkgnd_data : torch.Tensor, default None
            In case of setting fast_calc to False, which makes the algorithm
            require background data in SHAP during the feature importance, the
            background data used in the explainer can be set through this
            parameter.

        if fast_calc is True:

        max_iter : int, default 100
            Maximum number of iterations of the mask filter optimization, for
            each instance.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        lr : float, default 0.001
            Learning rate used in the optimization algorithm of the mask filter.
        recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
            Pointer to the recurrent layer in the model, if it exists. It should
            either be a LSTM, GRU or RNN network. If none is specified, the
            method will automatically search for a recurrent layer in the model.
        create_new_explainer : bool, default True
            Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
            previously defined one in the current model interpreter object.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            mask filter optimization loss.

        Returns
        -------
        feat_scores : numpy.Array
            Array containing the importance scores of each feature, of each
            instance, in the given input sequences.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        if fast_calc is None:
            # Use the predefined option if fast_calc isn&#39;t set in the function call
            fast_calc = self.fast_calc
        else:
            self.fast_calc = fast_calc
        if model_type is None:
            # Use the predefined option if model_type isn&#39;t set in the function call
            model_type = self.model_type
        else:
            self.model_type = model_type
        if total_length is None:
            # Use the predefined option if total_length isn&#39;t set in the function call
            total_length = self.total_length

        if model_type == &#39;multivariate_rnn&#39;:
            # Sort the test data by sequence length
            test_data, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict)
        # Set an indicator to log that the current model is a RNN
        isRNN = model_type == &#39;multivariate_rnn&#39;
        # Set an indicator to log that the current model is a bidirectional
        isBidir = self.model.bidir

        if method.lower() == &#39;shap&#39;:
            if create_new_explainer is True:
                # Go through all of the steps of initialiazing a new SHAP KernelExplainer
                if fast_calc:
                    print(f&#39;Attention: you have chosen to interpret the model using SHAP, with one background sample (all zeros), with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                    print(&#39;Evaluating the model with a reference value of zero. This should only be done if all the data is processed in a way that, for categorical features, 0 represents missing attribute and, for continuous features, 0 represents the average value of that feature.&#39;)
                    # Use a single all zeroes sample as a reference value
                    num_id_features = sum([1 if i is not None else 0 for i in [self.id_column_num, self.inst_column_num]])
                    bkgnd_data = np.zeros((1, len(self.feat_names) + num_id_features))
                else:
                    print(f&#39;Attention: you have chosen to interpret the model using SHAP, with {bkgnd_data.shape[0]} background samples, with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                    if model_type.lower() == &#39;multivariate_rnn&#39;:
                        # Sort the background data by sequence length
                        bkgnd_data, x_lengths_bkgnd = du.padding.sort_by_seq_len(bkgnd_data, self.seq_len_dict)
                        # Convert the background data into a 2D NumPy matrix
                        bkgnd_data = du.deep_learning.ts_tensor_to_np_matrix(bkgnd_data, self.feat_num, self.padding_value)
                    elif model_type.lower() == &#39;mlp&#39;:
                        # Just convert background data into a NumPy matrix
                        bkgnd_data = bkgnd_data.numpy()
                if model_type.lower() == &#39;multivariate_rnn&#39;:
                    # Convert the test data into a 2D NumPy matrix
                    test_data = du.deep_learning.ts_tensor_to_np_matrix(test_data, self.feat_num, self.padding_value)
                elif model_type.lower() == &#39;mlp&#39;:
                    # Remove ID columns from the data
                    bkgnd_data = du.deep_learning.remove_tensor_column(bkgnd_data, [self.id_column_num, self.inst_column_num], inplace=True)
                    test_data = du.deep_learning.remove_tensor_column(test_data, [self.id_column_num, self.inst_column_num], inplace=True)
                    # Convert test data into a NumPy matrix
                    test_data = test_data.numpy()
                # Create a function that represents the model&#39;s feedforward operation on a single instance
                kf = KernelFunction(self.model, model_type=model_type)
                # Use the background dataset to integrate over
                print(&#39;Creating a SHAP kernel explainer...&#39;)
                # [TODO] Removing this part of directly handling pure RNN models, as the `is_custom` parameter collides
                # with other definitions of it; ignoring for now as I&#39;m never using pure RNNs, without any modification
                # or at least wrapping in some class.
                # if self.is_custom is False:
                    # # Let SHAP find the recurrent layer
                    # recur_layer = None
                # else:
                # When using custom models, the whole model behaves as a recurrent layer
                # We just need to make sure that it returns the hidden state
                recur_layer = partial(self.model.forward, get_hidden_state=True)
                self.explainer = shap.KernelExplainer(kf.f, bkgnd_data, isRNN=isRNN, isBidir=isBidir,
                                                      model_obj=self.model, max_bkgnd_samples=100,
                                                      id_col_num=self.id_column_num,
                                                      ts_col_num=self.inst_column_num,
                                                      recur_layer=recur_layer)
            # Count the time that takes to calculate the SHAP values
            start_time = time.time()
            # Explain the predictions of the sequences in the test set
            print(&#39;Calculating feature importance scores for each instance in the test data...&#39;)
            feat_scores = self.explainer.shap_values(test_data, l1_reg=&#39;num_features(10)&#39;, nsamples=self.SHAP_bkgnd_samples, max_seq_len=total_length)
            print(f&#39;Calculation of SHAP values took {time.time() - start_time} seconds&#39;)
            return feat_scores

        else:
            # [TODO] Fix mask filter feature importance
            # [TODO] Add fast and slower versions of the mask filter
            # Remove identifier columns from the test data
            test_data = test_data[:, :, self.feat_num]
            # Make sure that the test data is in type float
            test_data = test_data.float()
            # Count the time that takes to calculate the SHAP values
            start_time = time.time()
            # Apply mask filter
            feat_scores, loss_mtx = self.mask_filter(test_data, x_lengths_test, max_iter,
                                                     l1_coeff, lr, recur_layer, debug_loss)
            print(f&#39;Calculation of mask filter values took {time.time() - start_time} seconds&#39;)
            if debug_loss:
                return feat_scores, loss_mtx
            else:
                return feat_scores
        # [TODO] Add more interpretability techniques, such as LIME and Agglomerative Contextual Decomposition (ACD)

    # [Bonus TODO] Upload model explainer and interpretability plots to Comet.ml
    def interpret_model(self, bkgnd_data=None, test_data=None, test_labels=None,
                        new_data=False, model_type=None, df=None,
                        instance_importance=True, feature_importance=False,
                        fast_calc=None, create_new_explainer=True,
                        see_progress=True, save_data=True, debug_loss=False,
                        total_length=None):
        &#39;&#39;&#39;Method to calculate scores of feature and/or instance importance, in
        order to be able to interpret a model on a given data.

        Parameters
        ----------
        bkgnd_data : torch.Tensor, default None
            In case of setting fast_calc to False, which makes the algorithm
            require background data in SHAP during the feature importance, the
            background data used in the explainer can be set through this
            parameter.
        test_data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance) as a PyTorch tensor. Otherwise, all the data is
            used.
        test_labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        new_data : bool, default False
            If set to True, it indicates that the data that will be interpreted
            hasn&#39;t been seen before, i.e. it has different ids than those in the
            original dataset defined in the object initialization. This implies
            that a dataframe of the new data is provided (parameter df) so that
            the sequence lengths are calculated. Otherwise, the original
            sequence lengths known by the model interpreter are used.
        model_type : string, default None
            Sets the type of machine learning model. Important to know what type
            of inference and data processing to do. Currently available options
            are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
        df : pandas.DataFrame, default None
            Dataframe containing the new data so as to calculate the sequence
            lengths of the new ids. Only used if new_data is set to True and
            `model_type` is &#39;multivariate_rnn&#39;.
        instance_importance : bool, default True
            If set to True, instance importance is made on the data. In other
            words, the algorithm will analyze the impact that each instance of
            an input sequence had on the output.
        feature_importance : bool or string, default False
            Defines which feature importance interpretability technique to use.
            The algorithm will analyze the impact that each feature of
            an instance had on the output. This is analyzed instance by instance,
            not in the entire sequence at once. For example, from the feature
            importance alone, it&#39;s not straightforward how a value in a previous
            instance impacted the current output. Current options include SHAP
            Kernel Explainer (&#39;shap&#39;) and &#39;mask filter&#39;. If set to False, no
            feature importance will be done.
        fast_calc : bool, default None
            If set to True, the algorithm uses less background samples (SHAP)
            or optimization steps (mask filter), in order to do a fast
            interpretation of the model. If set to False, the process takes
            more time in order to get a more precise and truthful
            interpretation of the model&#39;s behavior, requiring longer
            computation times.
        create_new_explainer : bool, default True
            Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
            previously defined one in the current model interpreter object.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the instance importance scores calculations.
        save_data : bool, default True
            If set to True, the possible background data (used in the SHAP
            explainer) and the test data (on which importance scores are
            calculated) are saved as object attributes.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            mask filter optimization loss.
        total_length : int, default None
            If not None, the feature importance scores will be padded to have
            length total_length.

        Returns
        -------
        inst_scores : numpy.Array
            Array containing the importance scores of each instance in the
            given input sequences. Only calculated if instance_importance is set
            to True.
        feat_scores : numpy.Array
            Array containing the importance scores of each feature, of each
            instance, in the given input sequences. Only calculated if
            feature_importance is set to True.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        # Confirm that the model is in evaluation mode to deactivate dropout
        self.model.eval()

        if feature_importance is not None and feature_importance is not False:
            try:
                feature_importance = feature_importance.lower()
                if feature_importance != &#39;shap&#39; and feature_importance != &#39;mask filter&#39;:
                    raise Exception(f&#39;ERROR: Specified {feature_importance} feature importance method isn\&#39;t valid. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)
            except:
                raise Exception(f&#39;ERROR: {feature_importance} is an incorrectly defined feature importance method, as it should be a string. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)

        if fast_calc is None:
            # Use the predefined option if fast_calc isn&#39;t set in the function call
            fast_calc = self.fast_calc
        else:
            self.fast_calc = fast_calc
        if model_type is None:
            # Use the predefined option if model_type isn&#39;t set in the function call
            model_type = self.model_type
        else:
            self.model_type = model_type
        if total_length is None:
            # Use the predefined option if total_length isn&#39;t set in the function call
            total_length = self.total_length

        if test_labels is not None:
            if type(test_labels) is np.ndarray:
                # Convert from numpy to pytorch
                test_labels = torch.from_numpy(test_labels)

        if test_data is None:
            if fast_calc:
                # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
                test_data = self.data
                test_labels = self.labels
            else:
                if bkgnd_data is None:
                    # Get the background and test sets from the dataset
                    bkgnd_data, test_data = self.create_bkgnd_test_sets()
                else:
                    # Get the test set from the dataset
                    _, test_data = self.create_bkgnd_test_sets()
        elif type(test_data) is np.ndarray:
            # Convert from numpy to pytorch
            test_data = torch.from_numpy(test_data)

        if model_type == &#39;multivariate_rnn&#39;:
            if new_data is True:
                if df is None:
                    raise Exception(&#39;ERROR: A dataframe must be provided in order to work with the new data.&#39;)
                # Find the sequence lengths of the new data
                seq_len_dict = du.padding.get_sequence_length_dict(df, id_column=self.id_column_num, ts_column=self.inst_column_num)
                # Sort the data by sequence length
                test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, seq_len_dict, test_labels)
            else:
                # Sort the data by sequence length
                test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict, test_labels)

        if not fast_calc:
            if bkgnd_data is None:
                # Get the background set from the dataset
                bkgnd_data, _ = self.create_bkgnd_test_sets()
            elif type(bkgnd_data) is np.ndarray:
                # Convert from numpy to pytorch
                bkgnd_data = torch.from_numpy(bkgnd_data)

        if save_data:
            # Save the data used in the model interpretation
            self.bkgnd_data = bkgnd_data
            self.test_data = test_data
            self.test_labels = test_labels

        if instance_importance is True:
            print(&#39;Calculating instance importance scores...&#39;)
            # Calculate the scores of importance of each instance
            self.inst_scores = self.instance_importance(test_data, test_labels, x_lengths_test, see_progress)

        if feature_importance is not False:
            print(&#39;Calculating feature importance scores...&#39;)
            # Calculate the scores of importance of each feature in each instance
            if feature_importance == &#39;mask filter&#39; and debug_loss:
                self.feat_scores, loss_mtx = self.feature_importance(test_data, model_type,
                                                                     feature_importance,
                                                                     fast_calc, see_progress,
                                                                     bkgnd_data, debug_loss=True,
                                                                     total_length=total_length)
            else:
                self.feat_scores = self.feature_importance(test_data, model_type, feature_importance,
                                                           fast_calc, see_progress, bkgnd_data,
                                                           create_new_explainer=create_new_explainer,
                                                           debug_loss=False, total_length=total_length)

        print(&#39;Done!&#39;)

        if instance_importance and feature_importance:
            if fast_calc and debug_loss:
                return self.inst_scores, self.feat_scores, loss_mtx
            else:
                return self.inst_scores, self.feat_scores
        elif instance_importance and not feature_importance:
            return self.inst_scores
        elif not instance_importance and feature_importance:
            if fast_calc and debug_loss:
                return self.feat_scores, loss_mtx
            else:
                return self.feat_scores
        else:
            warnings.warn(&#39;Without setting instance_importance nor feature_importance to True, the interpret_model function won\&#39;t do anything relevant.&#39;)
            return


    def instance_importance_plot(self, orig_data=None, inst_scores=None, seq_id=None,
                                 pred_prob=None, uniform_spacing=False,
                                 show_pred_prob=True, show_title=True,
                                 show_colorbar=True, click_mode=&#39;event+select&#39;,
                                 labels=None, seq_len=None, threshold=0,
                                 get_fig_obj=False, tensor_idx=True,
                                 max_seq=10, background_color=&#39;white&#39;,
                                 font_family=&#39;Roboto&#39;, font_size=14,
                                 font_color=&#39;black&#39;):
        &#39;&#39;&#39;Create a bar chart that allows visualizing instance importance scores.

        Parameters
        ----------
        orig_data : torch.Tensor or numpy.Array, default None
            Original data used in the machine learning model. Used here to fetch
            the true ID corresponding to the plotted sequence.
        inst_scores : numpy.Array, default None
            Array containing the instance importance scores to be plotted.
        seq_id : int, default None
            ID or sequence index that select which time series / sequences to
            use in the plot. If it&#39;s a single value, the method plots a single
            sequence.
        pred_prob : numpy.Array or torch.Tensor or list of floats, default None
            Array containing the prediction probabilities for each sequence in
            the input data (orig_data). Only relevant if show_pred_prob is True.
        uniform_spacing : bool, default False
            Defines whether or not the sequences are displayed with uniform
            spacing (i.e. fixed distance) between their samples.
        show_pred_prob : bool, default True
            If set to True, a percentage bar chart will be shown to the right of
            the standard instance importance plot. If `pred_prob` isn&#39;t
            specified but the labels are, the prediction probabilities will be
            automatically calculated.
        show_title : bool, default True
            If set to True, the plot will have a title displayed above.
        show_colorbar : bool, default True
            If set to True, a bar legend will be shown, corresponding each color
            to each respective value.
        click_mode : string, default &#39;event+select&#39;
            Determines the mode of single click interactions. &#34;event&#34; is the
            default value and emits the `plotly_click` event. In addition this
            mode emits the `plotly_selected` event in drag modes &#34;lasso&#34; and
            &#34;select&#34;, but with no event data attached (kept for compatibility
            reasons). The &#34;select&#34; flag enables selecting single data points via
            click. This mode also supports persistent selections, meaning that
            pressing Shift while clicking, adds to / subtracts from an existing
            selection. &#34;select&#34; with `hovermode`: &#34;x&#34; can be confusing, consider
            explicitly setting `hovermode`: &#34;closest&#34; when using this feature.
            Selection events are sent accordingly as long as &#34;event&#34; flag is set
            as well. When the &#34;event&#34; flag is missing, `plotly_click` and
            `plotly_selected` events are not fired.
        labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        seq_len : int, default None
            Sequence lengths which represent the true, unpadded size of the
            input sequences.
        threshold : int or float, default 0
            Value to use as a threshold in the plot&#39;s color selection. In other
            words, values that exceed this threshold will have one color while the
            remaining have a different one, as specified in the parameters.
        get_fig_obj : bool, default False
            If set to True, the function returns the object that contains the
            displayed plotly figure.
        tensor_idx : bool, default True
            If set to True, the ID specified in the respective parameter
            constitutes the index where the desired sequence resides. Otherwise,
            it&#39;s the actual unique identifier that appears in the original data.
        max_seq : int, default 10
            Maximum number of sequences to show in the plot. This is meant to
            prevent cramming too many sequences into the graph window.
        background_color : str, default &#39;white&#39;
            The plot&#39;s background color. Can be set in color name (e.g. &#39;white&#39;),
            hexadecimal code (e.g. &#39;#555&#39;) or RGB (e.g. &#39;rgb(0,0,255)&#39;).
        font_family : str, default &#39;Roboto&#39;
            Text font family to be used in the numbers shown next to the graph.
        font_size : int, default 14
            Text font size to be used in the numbers shown next to the graph.
        font_color : str, default &#39;black&#39;
            Text font color to be used in the numbers shown next to the graph. Can
            be set in color name (e.g. &#39;white&#39;), hexadecimal code (e.g. &#39;#555&#39;) or
            GB (e.g. &#39;rgb(0,0,255)&#39;).

        Returns
        -------
        fig : plotly.graph_objs.Figure or None
            If argument get_fig_obj is set to True, the figure object is returned.
            Otherwise, nothing is returned, only the plot is showned.&#39;&#39;&#39;
        if orig_data is None:
            # Use all the data if none was specified
            orig_data = self.data

            if labels is None:
                labels = self.labels

        if inst_scores is None:
            if self.inst_scores is None:
                raise Exception(&#39;ERROR: No instance importance scores found. If the scores aren\&#39;t specified, then they must have already been calculated through the interpret_model method.&#39;)
            # Use all the previously calculated scores if none were specified
            inst_scores = self.inst_scores

        # Plot the instance importance of multiple sequences
        # Convert the instance scores data into a NumPy array
        if type(inst_scores) is torch.Tensor:
            inst_scores = inst_scores.detach().numpy()
        elif type(inst_scores) is list:
            inst_scores = np.array(inst_scores)

        # if is not tensor_idx:
        # [TODO] Search for the index associated to the specific ID asked for by the user
        # [TODO] Allow to search for multiple indeces and generate a multiple patients time series plot from it

        if len(inst_scores.shape) == 1 or (seq_id is not None and type(seq_id) is not list):
            # True sequence length of the current id&#39;s data
            if seq_len is None:
                seq_len = self.seq_len_dict[orig_data[seq_id, 0, self.id_column_num].item()]

            # [TODO] Add a prediction probability bar plot like in the multiple sequences case

            # Plot the instance importance of one sequence
            plot_data = [go.Bar(
                            x = list(range(seq_len)),
                            y = inst_scores[seq_id, :seq_len],
                            marker=dict(color=du.utils.set_bar_color(inst_scores, seq_id, seq_len,
                                                                     threshold=threshold,
                                                                     pos_color=POS_COLOR,
                                                                     neg_color=NEG_COLOR))
                          )]
            layout = go.Layout(
                                title=f&#39;Instance importance scores for ID {int(orig_data[id, 0, self.id_column_num])}&#39;,
                                xaxis=dict(title=&#39;Instance&#39;),
                                yaxis=dict(title=&#39;Importance scores&#39;)
                              )
        else:
            if seq_id is None:
                # Use all the sequences data if a subset isn&#39;t specified
                seq_id = list(range(inst_scores.shape[0]))
            # Select the desired data according to the specified IDs
            inst_scores = inst_scores[seq_id, :]
            orig_data = orig_data[seq_id, :, :]
            # Unique patient IDs in string format
            patients = [str(int(item)) for item in [tensor.item()
                        for tensor in list(orig_data[:, 0, self.id_column_num])]]
            if uniform_spacing is True:
                # Sequence instances count, used as X in the plot
                seq_insts_x = [list(range(inst_scores.shape[1]))
                               for patient in range(len(patients))]
            else:
                # Use the original timestamp values as the X axis
                seq_insts_x = [int(tensor) for seq_list
                               in [list(ts_array) for ts_array in list(orig_data[:, :, self.inst_column_num])]
                               for tensor in seq_list]
            # Patients ids repeated max sequence length times, used as Y in the plot
            patients_y = [[patient]*inst_scores.shape[1] for patient in list(patients)]
            # Flatten seq_insts and patients_y
            seq_insts_x = list(np.array(seq_insts_x).flatten())
            patients_y = list(np.array(patients_y).flatten())
            # Define colors for the data points based on their normalized scores (from 0 to 1 instead of -1 to 1)
            colors = [val for val in inst_scores.flatten()]
            # Count the number of already deleted paddings
            count = 0

            for i in range(inst_scores.shape[0]):
                for j in range(inst_scores.shape[1]):
                    if inst_scores[i, j] == self.padding_value:
                        # Delete elements that represent paddings, not real instances
                        del seq_insts_x[i*inst_scores.shape[1]+j-count]
                        del patients_y[i*inst_scores.shape[1]+j-count]
                        del colors[i*inst_scores.shape[1]+j-count]
                        # Increment the counting of already deleted items
                        count += 1

            if show_pred_prob is True:
                if pred_prob is None:
                    if labels is None:
                        raise Exception(&#39;ERROR: By setting `show_pred_prob` to True, either the prediction probabilities (pred_prob) or the labels must be provided.&#39;)
                    # Calculate the prediction probabilities for the provided data
                    pred_prob, _ = du.deep_learning.model_inference(self.model, data=(orig_data, labels),
                                                                    metrics=[&#39;&#39;], model_type=self.model_type,
                                                                    is_custom=self.is_custom,
                                                                    seq_len_dict=self.seq_len_dict,
                                                                    padding_value=self.padding_value,
                                                                    output_rounded=False,
                                                                    seq_final_outputs=True,
                                                                    cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                                    already_embedded=self.already_embedded)
                # Convert the prediction probability data into a NumPy array
                if type(pred_prob) is torch.Tensor:
                    pred_prob = pred_prob.detach().numpy()
                elif type(pred_prob) is list:
                    pred_prob = np.array(pred_prob)
                # Select the desired data according to the specified IDs
                pred_prob = pred_prob[seq_id]
                # Colors to use in the prediction probability bar plots
                pred_colors = cl.scales[&#39;8&#39;][&#39;div&#39;][&#39;RdYlGn&#39;]
                # Create &#34;percentage bar&#34; plots through pairs of unfilled and filled rectangles
                shapes_list = []
                # Starting y coordinate of the first shape
                y0 = -0.25
                # Height of the shapes (y length)
                step = 0.5
                # Maximum width of the shapes
                max_width = 1
                for i in range(len(patients)):
                    # Set the starting x coordinate to after the last data point
                    x0 = inst_scores.shape[1]
                    # Set the filling length of the shape
                    x1_fill = x0 + pred_prob[i] * max_width
                    shape_unfilled = {
                                        &#39;type&#39;: &#39;rect&#39;,
                                        &#39;x0&#39;: x0,
                                        &#39;y0&#39;: y0,
                                        &#39;x1&#39;: x0 + max_width,
                                        &#39;y1&#39;: y0 + step,
                                        &#39;line&#39;: {
                                                    &#39;color&#39;: &#39;rgba(0, 0, 0, 1)&#39;,
                                                    &#39;width&#39;: 2,
                                                },
                                    }
                    shape_filled = {
                                        &#39;type&#39;: &#39;rect&#39;,
                                        &#39;x0&#39;: x0,
                                        &#39;y0&#39;: y0,
                                        &#39;x1&#39;: x1_fill,
                                        &#39;y1&#39;: y0 + step,
                                        &#39;fillcolor&#39;: pred_colors[int(len(pred_colors)-1-max(pred_prob[i]*len(pred_colors)-1, 0))]
                                    }
                    shapes_list.append(shape_unfilled)
                    shapes_list.append(shape_filled)
                    # Set the starting y coordinate for the next shapes
                    y0 = y0 + 2 * step

                # Getting points along the percentage bar plots
                x_range = [list(np.array(range(0, 10, 1))*0.1+inst_scores.shape[1]) for idx in range(len(patients))]
                # Flatten the list
                text_x = [item for sublist in x_range for item in sublist]
                # Y coordinates of the prediction probability text
                text_y = [patient for patient in patients for idx in range(10)]
                # Prediction probabilities in text form, to appear in the plot
                text_content = [pred_prob[idx] for idx in range(len(pred_prob)) for i in range(10)]
                # [TODO] Ajdust the zoom so that the initial plot doens&#39;t block part of the first and last sequences that show up

            # Create plotly chart
            plot_data = [dict(
                x=seq_insts_x,
                y=patients_y,
                marker=dict(
                    color=colors,
                    size=12,
                    line = dict(
                        color = &#39;black&#39;,
                        width = 1
                    ),
                    colorscale=[[0, &#39;rgba(30,136,229,1)&#39;], [0.5, &#39;white&#39;], [1, &#39;rgba(255,13,87,1)&#39;]],
                    cmax=1,
                    cmin=-1,
                ),
                mode=&#39;markers&#39;,
                type=&#39;scatter&#39;,
                hoverinfo=&#39;x+y&#39;
            )]
            layout = dict(
                paper_bgcolor=background_color,
                plot_bgcolor=background_color,
                font=dict(
                    family=font_family,
                    size=font_size,
                    color=font_color
                ),
                xaxis=dict(
                    title=&#39;Instance&#39;,
                    showgrid=False,
                    zeroline=False
                ),
                yaxis=dict(
                    title=&#39;Patient ID&#39;,
                    showgrid=False,
                    zeroline=False,
                    type=&#39;category&#39;
                ),
                hovermode=&#39;closest&#39;,
                showlegend=False,
                clickmode=click_mode
            )
            if show_title is True:
                layout[&#39;title&#39;] = &#39;Instance importance&#39;
                layout[&#39;margin&#39;] = dict(l=0, r=0, t=30, b=0, pad=0)
            else:
                layout[&#39;margin&#39;] = dict(l=0, r=0, t=0, b=0, pad=0)
            if show_colorbar is True:
                layout[&#39;meta&#39;] = dict()
                layout[&#39;meta&#39;][&#39;colorbar&#39;] = dict(title=&#39;Scores&#39;)
            if show_pred_prob is True:
                # Add hover text to indicate the final output probabilities
                prob_hover_info = go.Scatter(
                    x=text_x,
                    y=text_y,
                    text=text_content,
                    mode=&#39;text&#39;,
                    textfont=dict(size = 1, color=&#39;#ffffff&#39;),
                    hoverinfo=&#39;y+text&#39;
                )
                plot_data.append(prob_hover_info)
                # Add final output probabilities bar plots
                layout[&#39;shapes&#39;] = shapes_list
            if len(patients) &gt; max_seq:
                # Prevent cramming too many sequences into the plot
                layout[&#39;yaxis&#39;][&#39;range&#39;] = [patients[max_seq], patients[0]]
        # Show the plot
        fig = go.Figure(plot_data, layout)

        if get_fig_obj:
            # Only return the figure object if specified by the user
            return fig
        else:
            py.iplot(fig)
            return

    # [TODO] Develop function to explain, in text form, why a given input data has a certain output.
    # The results gather with instance and feature importance, as well as counter-examples, should
    # be used.
    # def explain_output(self, data, detailed_explanation=True):
        # if detailed_explanation:
        #     inst_scores, feat_scores = self.interpret_model(test_data=data, instance_importance=True,
        #                                                     feature_importance=True, fast_calc=False)
        #
            # [TODO] Explain the most important instances and most important features on those instances
            # [TODO] Compare with counter-examples, i.e. cases where the classification was different
        # else:
        #     inst_scores, feat_scores = self.interpret_model(test_data=data, instance_importance=True,
        #                                                     feature_importance=True, fast_calc=True)
        #
            # [TODO] Explain the most important instances and most important features on those instances

    # [TODO] Define an automatic method to discover which embedded category was more
    # important by doing inference on individual embeddings of each category separately,
    # seeing which one caused a bigger change in the output.

    def shap_values_df(self):
        &#39;&#39;&#39;Create a dataframe that contains both the original data used in the
        interpretation of the model and the resulting SHAP values.

        Returns
        -------
        data_n_shap_df : pandas.DataFrame
            Dataframe that contains both the original data used in the
            interpretation of the model and the resulting SHAP values.&#39;&#39;&#39;
        # [TODO] Add option to handle pre-calculated SHAP values
        # (pre-defined data and SHAP values, outside of the Model Interpreter)
        # Join the original data and the features&#39; SHAP values
        data_n_shap = np.concatenate([self.test_data.numpy(), self.test_labels.unsqueeze(2).numpy(), self.feat_scores], axis=2)
        # Reshape into a 2D format
        data_n_shap = data_n_shap.reshape(-1, data_n_shap.shape[-1])
        # Remove padding samples
        data_n_shap = data_n_shap[[self.padding_value not in row for row in data_n_shap]]
        # Define the column names list
        shap_column_names = [f&#39;{feature}_shap&#39; for feature in self.feat_names]
        column_names = ([self.id_column_name] + [self.inst_column_name] + self.feat_names
                        + [self.label_column_name] + shap_column_names)
        # Create the dataframe
        data_n_shap_df = pd.DataFrame(data=data_n_shap, columns=column_names)
        return data_n_shap_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="model_interpreter.model_interpreter.calc_instance_score"><code class="name flex">
<span>def <span class="ident">calc_instance_score</span></span>(<span>model, sequence_data, instance, ref_output, x_length, occlusion_wgt=0.7, id_column=0, inst_column=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the instance importance score for a given instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>nn.Module</code></dt>
<dd>Machine learning model which will be interpreted.</dd>
<dt><strong><code>sequence_data</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Data corresponding to the data sequence to which the current instance
belongs to.</dd>
<dt><strong><code>instance</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of the instance in the sequence. e.g. in a medical time series,
the second clinical visit of a patient would be the instance number 1
(counting starts at 0).</dd>
<dt><strong><code>ref_output</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Original model outputs of each instance in the sequence.</dd>
<dt><strong><code>x_length</code></strong> :&ensp;<code>int</code></dt>
<dd>True sequence length, dismissing padding.</dd>
<dt><strong><code>occlusion_wgt</code></strong> :&ensp;<code>float</code>, default <code>0.7</code></dt>
<dd>Weight given to the occlusion part of the instance importance score.
This scores is calculated as a weighted average of the instance's
influence on the final output and the variation of the output
probability, between the current instance and the previous one. As
such, this weight should have a value between 0 and 1, with the
output variation receiving the remaining weight (1 - occlusion_wgt),
where 0 corresponds to not using the occlusion component at all, 0.5
is a normal, unweighted average and 1 deactivates the use of the
output variation part. If the value wasn't specified in the
intepreter's initialization nor in the method argument, it will
default to 0.7</dd>
<dt><strong><code>id_column</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Number of the column which corresponds to the subject identifier in
the data tensor.</dd>
<dt><strong><code>inst_column</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Number of the column which corresponds to the instance or timestamp
identifier in the data tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inst_score</code></strong> :&ensp;<code>float</code></dt>
<dd>Instance importance score calculated for the current instance, with the
specified parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_instance_score(model, sequence_data, instance, ref_output, x_length,
                        occlusion_wgt=0.7, id_column=0, inst_column=1):
    &#39;&#39;&#39;Calculate the instance importance score for a given instance.

    Parameters
    ----------
    model : nn.Module
        Machine learning model which will be interpreted.
    sequence_data : torch.Tensor
        Data corresponding to the data sequence to which the current instance
        belongs to.
    instance : int
        Number of the instance in the sequence. e.g. in a medical time series,
        the second clinical visit of a patient would be the instance number 1
        (counting starts at 0).
    ref_output : torch.Tensor
        Original model outputs of each instance in the sequence.
    x_length : int
        True sequence length, dismissing padding.
    occlusion_wgt : float, default 0.7
            Weight given to the occlusion part of the instance importance score.
            This scores is calculated as a weighted average of the instance&#39;s
            influence on the final output and the variation of the output
            probability, between the current instance and the previous one. As
            such, this weight should have a value between 0 and 1, with the
            output variation receiving the remaining weight (1 - occlusion_wgt),
            where 0 corresponds to not using the occlusion component at all, 0.5
            is a normal, unweighted average and 1 deactivates the use of the
            output variation part. If the value wasn&#39;t specified in the
            intepreter&#39;s initialization nor in the method argument, it will
            default to 0.7
    id_column : int, default 0
            Number of the column which corresponds to the subject identifier in
            the data tensor.
    inst_column : int, default 1
        Number of the column which corresponds to the instance or timestamp
        identifier in the data tensor.

    Returns
    -------
    inst_score : float
        Instance importance score calculated for the current instance, with the
        specified parameters.
    &#39;&#39;&#39;
    # Remove identifier columns from the data
    sequence_data = du.deep_learning.remove_tensor_column(sequence_data, [id_column, inst_column], inplace=True)
    # Indeces without the instance that is being analyzed
    instances_idx = list(range(sequence_data.shape[0]))
    instances_idx.remove(instance)
    # Sequence data without the instance that is being analyzed
    sequence_data = sequence_data[instances_idx, :]
    # Add a third dimension for the data to be readable by the model
    sequence_data = sequence_data.unsqueeze(0)
    # Update the sequence length as the instance is removed
    new_seq_length = x_length-1
    # Calculate the output without the instance that is being analyzed
    new_output = model(sequence_data[:, :new_seq_length, :])
    # Only use the last output (i.e. the one from the last instance of the sequence)
    new_output = new_output[new_seq_length-1].item()
    # Flag that indicates whether the output variation component will be used in the instance importance score
    # (in a weighted average)
    use_outvar_score = ref_output.shape[0] &gt; 1 and instance &gt; 0
    if use_outvar_score:
        # Get the output from the previous instance
        prev_output = ref_output[instance-1].item()
        # Get the output from the current instance
        curr_output = ref_output[instance].item()
    # Get the last output
    ref_output = ref_output[x_length-1].item()
    # The instance importance score is then the difference between the output probability with the instance
    # and the probability without the instance
    inst_score = ref_output - new_output
    if instance &gt; 0 and use_outvar_score:
        # If it&#39;s not the first instance, add the output variation characteristic in a weighted average
        inst_score = occlusion_wgt * inst_score + (1 - occlusion_wgt) * (curr_output - prev_output)
    # Apply a tanh function to make even the smaller scores (which are the most frequent) more salient
    inst_score = np.tanh(4 * inst_score)
    return inst_score</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="model_interpreter.model_interpreter.KernelFunction"><code class="flex name class">
<span>class <span class="ident">KernelFunction</span></span>
<span>(</span><span>model, model_type='multivariate_rnn')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KernelFunction:
    def __init__(self, model, model_type=&#39;multivariate_rnn&#39;):
        # Save the model object to be used in the main function
        self.model = model
        # Log the model type
        model_type = model_type.lower()
        if model_type == &#39;multivariate_rnn&#39; or model_type == &#39;mlp&#39;:
            self.model_type = model_type
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {model_type}.&#39;)

    def f(self, data, hidden_state=None):
        &#39;&#39;&#39;Function that will be used in the SHAP kernel explainer, converting
        a NumPy array into the model&#39;s output.

        Parameters
        ----------
        data : numpy.ndarray
            Data corresponding to a single instance (or timestamp, in a time
            series) used in the SHAP kernel explainer.
        hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
            Hidden state coming from the previous recurrent cell. If none is
            specified, the hidden state is initialized as zero.

        Returns
        -------
        output : numpy.ndarray
            Output of the model obtained with the given instance data and
            possible hidden state.
        &#39;&#39;&#39;
        if isinstance(data, np.ndarray):
            # Make sure the data is of type float
            data = torch.from_numpy(data).float()
        # Calculate the output
        if self.model_type == &#39;multivariate_rnn&#39;:
            if len(data.shape) &lt; 3:
                data = data.unsqueeze(0)
            output = self.model(data, hidden_state=hidden_state)
        elif self.model_type == &#39;mlp&#39;:
            output = self.model(data)
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {self.model_type}.&#39;)
        if torch.cuda.is_available():
            return output.detach().cpu().numpy()
        else:
            return output.detach().numpy()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="model_interpreter.model_interpreter.KernelFunction.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, data, hidden_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that will be used in the SHAP kernel explainer, converting
a NumPy array into the model's output.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Data corresponding to a single instance (or timestamp, in a time
series) used in the SHAP kernel explainer.</dd>
<dt><strong><code>hidden_state</code></strong> :&ensp;<code>torch.Tensor</code> or <code>tuple</code> of <code>two torch.Tensor</code>, default <code>None</code></dt>
<dd>Hidden state coming from the previous recurrent cell. If none is
specified, the hidden state is initialized as zero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Output of the model obtained with the given instance data and
possible hidden state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(self, data, hidden_state=None):
    &#39;&#39;&#39;Function that will be used in the SHAP kernel explainer, converting
    a NumPy array into the model&#39;s output.

    Parameters
    ----------
    data : numpy.ndarray
        Data corresponding to a single instance (or timestamp, in a time
        series) used in the SHAP kernel explainer.
    hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
        Hidden state coming from the previous recurrent cell. If none is
        specified, the hidden state is initialized as zero.

    Returns
    -------
    output : numpy.ndarray
        Output of the model obtained with the given instance data and
        possible hidden state.
    &#39;&#39;&#39;
    if isinstance(data, np.ndarray):
        # Make sure the data is of type float
        data = torch.from_numpy(data).float()
    # Calculate the output
    if self.model_type == &#39;multivariate_rnn&#39;:
        if len(data.shape) &lt; 3:
            data = data.unsqueeze(0)
        output = self.model(data, hidden_state=hidden_state)
    elif self.model_type == &#39;mlp&#39;:
        output = self.model(data)
    else:
        raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {self.model_type}.&#39;)
    if torch.cuda.is_available():
        return output.detach().cpu().numpy()
    else:
        return output.detach().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter"><code class="flex name class">
<span>class <span class="ident">ModelInterpreter</span></span>
<span>(</span><span>model, data=None, labels=None, model_type='multivariate_rnn', is_custom=False, already_embedded=False, seq_len_dict=None, id_column_num=None, id_column_name=None, inst_column_num=None, inst_column_name=None, label_column_num=None, label_column_name=None, fast_calc=True, SHAP_bkgnd_samples='auto', random_seed=42, feat_names=None, padding_value=999999, occlusion_wgt=0.7, total_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A machine learning model interpreter which calculates instance and
feature importance.</p>
<p>The current focus of the class is to analyze neural networks built in
the PyTorch framework, which classify sequential data with potentially
variable sequence length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>nn.Module</code></dt>
<dd>Machine learning model which will be interpreted.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code> or <code>pandas.DataFrame</code>, default <code>None</code></dt>
<dd>Data used in the interpretation, either directly by analyzing the
outputs obtained with each sample or indireclty by using as
background data in methods such as SHAP explainers. The data will be
used in PyTorch tensor format, but the user can submit it as a
pandas dataframe, which is then automatically padded and converted.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Labels corresponding to the data used, either specified in the input
or all the data that the interpreter has.</dd>
<dt><strong><code>model_type</code></strong> :&ensp;<code>string</code>, default <code>'multivariate_rnn'</code></dt>
<dd>Sets the type of machine learning model. Important to know what type
of inference and data processing to do. Currently available options
are ['multivariate_rnn', 'mlp'].</dd>
<dt><strong><code>is_custom</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will assume that the model being used is a
custom built one, which won't require sequence length information during
the feedforward process.</dd>
<dt><strong><code>already_embedded</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, it means that the categorical features are already
embedded when fetching a batch, i.e. there's no need to run the embedding
layer(s) during the model's feedforward.</dd>
<dt><strong><code>seq_len_dict</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the sequence lengths for each index of the
original dataframe. This allows to ignore the padding done in
the fixed sequence length tensor.</dd>
<dt><strong><code>id_column_num</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Number of the column which corresponds to the subject identifier in
the data tensor.</dd>
<dt><strong><code>id_column_name</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Name of the column which corresponds to the subject identifier in
the data tensor.</dd>
<dt><strong><code>inst_column_num</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Number of the column which corresponds to the instance or timestamp
identifier in the data tensor.</dd>
<dt><strong><code>inst_column_name</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Name of the column which corresponds to the instance or timestamp
identifier in the data tensor.</dd>
<dt><strong><code>label_column_num</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Number of the column which corresponds to the label in the data
tensor. Only needed if the data is in dataframe format.</dd>
<dt><strong><code>label_column_name</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Name of the column which corresponds to the label in the data
tensor. Only needed if the data is in dataframe format.</dd>
<dt><strong><code>fast_calc</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the algorithm uses less background samples (SHAP)
or optimization steps (mask filter), in order to do a fast
interpretation of the model. If set to False, the process takes
more time in order to get a more precise and truthful
interpretation of the model's behavior, requiring longer
computation times.</dd>
<dt><strong><code>SHAP_bkgnd_samples</code></strong> :&ensp;<code>int</code>, default <code>'auto'</code></dt>
<dd>Number of samples to use as background data, in case a SHAP
explainer is applied (fast_calc must be set to False).</dd>
<dt><strong><code>random_seed</code></strong> :&ensp;<code>integer</code>, default <code>42</code></dt>
<dd>Seed used when shuffling the data.</dd>
<dt><strong><code>feat_names</code></strong> :&ensp;<code>list</code> of <code>string</code>, default <code>None</code></dt>
<dd>Column names of the dataframe associated to the data. If no list is
provided, the dataframe should be given in the data argument, so as
to fetch the names of the columns.</dd>
<dt><strong><code>padding_value</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Value to use in the padding, to fill the sequences.</dd>
<dt><strong><code>occlusion_wgt</code></strong> :&ensp;<code>float</code>, default <code>0.7</code></dt>
<dd>Weight given to the occlusion part of the instance importance score.
This scores is calculated as a weighted average of the instance's
influence on the final output and the variation of the output
probability, between the current instance and the previous one. As
such, this weight should have a value between 0 and 1, with the
output variation receiving the remaining weight (1 - occlusion_wgt),
where 0 corresponds to not using the occlusion component at all, 0.5
is a normal, unweighted average and 1 deactivates the use of the
output variation part.</dd>
<dt><strong><code>total_length</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>If not None, the feature importance scores will be padded to have
length total_length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelInterpreter:
    &#39;&#39;&#39;A machine learning model interpreter which calculates instance and
    feature importance.

    The current focus of the class is to analyze neural networks built in
    the PyTorch framework, which classify sequential data with potentially
    variable sequence length.

    Parameters
    ----------
    model : nn.Module
        Machine learning model which will be interpreted.
    data : torch.Tensor or pandas.DataFrame, default None
        Data used in the interpretation, either directly by analyzing the
        outputs obtained with each sample or indireclty by using as
        background data in methods such as SHAP explainers. The data will be
        used in PyTorch tensor format, but the user can submit it as a
        pandas dataframe, which is then automatically padded and converted.
    labels : torch.Tensor, default None
        Labels corresponding to the data used, either specified in the input
        or all the data that the interpreter has.
    model_type : string, default &#39;multivariate_rnn&#39;
        Sets the type of machine learning model. Important to know what type
        of inference and data processing to do. Currently available options
        are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
    is_custom : bool, default False
        If set to True, the method will assume that the model being used is a
        custom built one, which won&#39;t require sequence length information during
        the feedforward process.
    already_embedded : bool, default False
        If set to True, it means that the categorical features are already
        embedded when fetching a batch, i.e. there&#39;s no need to run the embedding
        layer(s) during the model&#39;s feedforward.
    seq_len_dict : dict, default None
        Dictionary containing the sequence lengths for each index of the
        original dataframe. This allows to ignore the padding done in
        the fixed sequence length tensor.
    id_column_num : int, default None
        Number of the column which corresponds to the subject identifier in
        the data tensor.
    id_column_name : string, default None
        Name of the column which corresponds to the subject identifier in
        the data tensor.
    inst_column_num : int, default None
        Number of the column which corresponds to the instance or timestamp
        identifier in the data tensor.
    inst_column_name : string, default None
        Name of the column which corresponds to the instance or timestamp
        identifier in the data tensor.
    label_column_num : int, default None
        Number of the column which corresponds to the label in the data
        tensor. Only needed if the data is in dataframe format.
    label_column_name : string, default None
        Name of the column which corresponds to the label in the data
        tensor. Only needed if the data is in dataframe format.
    fast_calc : bool, default True
        If set to True, the algorithm uses less background samples (SHAP)
        or optimization steps (mask filter), in order to do a fast
        interpretation of the model. If set to False, the process takes
        more time in order to get a more precise and truthful
        interpretation of the model&#39;s behavior, requiring longer
        computation times.
    SHAP_bkgnd_samples : int, default &#39;auto&#39;
        Number of samples to use as background data, in case a SHAP
        explainer is applied (fast_calc must be set to False).
    random_seed : integer, default 42
        Seed used when shuffling the data.
    feat_names : list of string, default None
        Column names of the dataframe associated to the data. If no list is
        provided, the dataframe should be given in the data argument, so as
        to fetch the names of the columns.
    padding_value : numeric
        Value to use in the padding, to fill the sequences.
    occlusion_wgt : float, default 0.7
        Weight given to the occlusion part of the instance importance score.
        This scores is calculated as a weighted average of the instance&#39;s
        influence on the final output and the variation of the output
        probability, between the current instance and the previous one. As
        such, this weight should have a value between 0 and 1, with the
        output variation receiving the remaining weight (1 - occlusion_wgt),
        where 0 corresponds to not using the occlusion component at all, 0.5
        is a normal, unweighted average and 1 deactivates the use of the
        output variation part.
    total_length : int, default None
        If not None, the feature importance scores will be padded to have
        length total_length.
    &#39;&#39;&#39;
    def __init__(self, model, data=None, labels=None, model_type=&#39;multivariate_rnn&#39;,
                 is_custom=False, already_embedded=False, seq_len_dict=None,
                 id_column_num=None, id_column_name=None, inst_column_num=None,
                 inst_column_name=None, label_column_num=None, label_column_name=None,
                 fast_calc=True, SHAP_bkgnd_samples=&#39;auto&#39;, random_seed=42,
                 feat_names=None, padding_value=999999, occlusion_wgt=0.7,
                 total_length=None):
        # Initialize parameters according to user input
        self.model = model
        self.data = data
        self.seq_len_dict = seq_len_dict
        self.id_column_num = id_column_num
        self.id_column_name = id_column_name
        self.inst_column_num = inst_column_num
        self.inst_column_name = inst_column_name
        self.label_column_num = label_column_num
        self.label_column_name = label_column_name
        self.fast_calc = fast_calc
        self.SHAP_bkgnd_samples = SHAP_bkgnd_samples
        self.random_seed = random_seed
        self.feat_names = feat_names
        self.padding_value = padding_value
        self.occlusion_wgt = occlusion_wgt
        self.total_length = total_length
        if model_type == &#39;multivariate_rnn&#39; or model_type == &#39;mlp&#39;:
            self.model_type = model_type
        else:
            raise Exception(f&#39;ERROR: Invalid model type. It must be &#34;multivariate_rnn&#34; or &#34;mlp&#34;, not {model_type}.&#39;)
        self.is_custom = is_custom
        self.already_embedded = already_embedded

        # Put the model in evaluation mode to deactivate dropout
        self.model.eval()

        if data is not None:
            if type(data) is torch.Tensor:
                self.data = data
                self.labels = labels
                if model_type == &#39;mlp&#39;:
                    self.data = du.deep_learning.remove_tensor_column(data, id_column, inplace=True)
            elif type(data) is np.ndarray:
                # Convert from numpy to pytorch
                self.data = torch.from_numpy(data)
                self.labels = torch.from_numpy(labels)
                if model_type == &#39;mlp&#39;:
                    self.data = du.deep_learning.remove_tensor_column(data, id_column, inplace=True)
            elif type(data) is pd.DataFrame:
                # Fetch the column names, ignoring the ID column
                self.feat_names = list(data.columns)
                if self.id_column_num is None and self.id_column_name is not None:
                    # Find the ID column number
                    self.id_column_num = du.search_explore.find_col_idx(data, self.id_column_name)
                elif self.id_column_num is not None and self.id_column_name is None:
                    # Convert the ID column index to the column name
                    self.id_column_name = self.feat_names[self.id_column_num]
                if self.inst_column_num is None and self.inst_column_name is not None:
                    # Find the instance column number
                    self.inst_column_num = du.search_explore.find_col_idx(data, self.inst_column_name)
                elif self.inst_column_num is not None and self.inst_column_name is None:
                    # Convert the instance column index to the column name
                    self.inst_column_name = self.feat_names[self.inst_column_num]
                if self.total_length is None:
                    # Find the maximum sequence length, so that the ML models and their related methods can handle all sequences, which have varying sequence lengths
                    self.total_length = data.groupby(self.id_column_name)[self.inst_column_name].count().max()
                if self.label_column_num is None:
                    if self.label_column_name is not None:
                        # Find the instance column number
                        self.label_column_num = du.search_explore.find_col_idx(data, self.label_column_name)
                    else:
                        # Counter that indicates in which column we&#39;re in when searching for the label column
                        col_num = 0
                        for col in data.columns:
                            if &#39;label&#39; in col:
                                # Column name corresponding to the label
                                self.label_column_name = col
                                # Column number corresponding to the label
                                self.label_column_num = col_num
                                break
                            col_num += 1
                if self.label_column_name is None:
                    self.label_column_name = self.feat_names[self.label_column_num]
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=[self.id_column_name,
                                                                       self.label_column_name],
                                                            update_idx=False)
                # Fetch the column numbers, ignoring the ID column
                self.feat_num = list(range(len(data.columns)))
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.id_column_num,
                                                          update_idx=False)
                # Also update the idx when removing the label, since the features
                # tensors aren&#39;t going to contain the label
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.label_column_num,
                                                          update_idx=True)
                if self.model_type == &#39;multivariate_rnn&#39;:
                    # Also ignore the instance ID column
                    self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                                to_remove=self.inst_column_name,
                                                                update_idx=False)
                    self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                              to_remove=self.inst_column_num,
                                                              update_idx=False)
                    # Find the sequence lengths of the data
                    self.seq_len_dict = du.padding.get_sequence_length_dict(data, id_column=self.id_column_name, ts_column=self.inst_column_name)
                    # Pad data (to have fixed sequence length) and convert into a PyTorch tensor
                    data_tensor = du.padding.dataframe_to_padded_tensor(data, seq_len_dict=self.seq_len_dict, id_column=self.id_column_name,
                                                                        ts_column=self.inst_column_name, padding_value=padding_value,
                                                                        label_column=self.label_column_name, total_length=self.total_length,
                                                                        inplace=True)
                    # Separate labels from features
                    dataset = du.datasets.Time_Series_Dataset(data, data_tensor,
                                                              seq_len_dict=self.seq_len_dict,
                                                              label_name=self.label_column_name)
                elif self.model_type == &#39;mlp&#39;:
                    # Convert into a PyTorch tensor
                    data_tensor = torch.from_numpy(data.numpy())
                    # Separate labels from features
                    dataset = du.datasets.Tabular_Dataset(data_tensor, data)

                self.data = dataset.X
                self.labels = dataset.y
            else:
                raise Exception(&#39;ERROR: Invalid data type. Please provide data in a Pandas DataFrame, PyTorch Tensor or NumPy Array format.&#39;)
        else:
            # Convert the column indeces to the column names
            if self.id_column_num is None and self.id_column_name is not None:
                # Find the ID column number
                self.id_column_num = self.feat_names.index(self.id_column_name)
            elif self.id_column_num is not None and self.id_column_name is None:
                # Convert the ID column index to the column name
                self.id_column_name = self.feat_names[self.id_column_num]
            if self.inst_column_num is None and self.inst_column_name is not None:
                # Find the instance column number
                self.inst_column_num =  self.feat_names.index(self.inst_column_name)
            elif self.inst_column_num is not None and self.inst_column_name is None:
                # Convert the instance column index to the column name
                self.inst_column_name = self.feat_names[self.inst_column_num]
            if self.label_column_num is None and self.label_column_name is not None:
                # Find the label column number
                self.label_column_num =  self.feat_names.index(self.label_column_name)
            elif self.label_column_num is not None and self.label_column_name is None:
                # Convert the label column index to the column name
                self.label_column_name = self.feat_names[self.label_column_num]
            # Fetch the column numbers, ignoring the ID column
            self.feat_num = list(range(len(self.feat_names)))
            self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                      to_remove=self.id_column_num,
                                                      update_idx=False)
            self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                        to_remove=self.id_column_name,
                                                        update_idx=False)
            if self.label_column_num is not None:
                # Also update the idx when removing the label, since the features
                # tensors aren&#39;t going to contain the label
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=self.label_column_name,
                                                            update_idx=False)
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                        to_remove=self.label_column_num,
                                                        update_idx=True)
            if self.model_type == &#39;multivariate_rnn&#39;:
                # Also ignore the instance ID column
                self.feat_names = du.utils.remove_from_list(self.feat_names,
                                                            to_remove=self.inst_column_name,
                                                            update_idx=False)
                self.feat_num = du.utils.remove_from_list(self.feat_num,
                                                          to_remove=self.inst_column_num,
                                                          update_idx=False)

        # Declare explainer attribute which will store the SHAP Explainer object
        self.explainer = None
        # Declare attributes that will store importance scores (instance and feature importance)
        self.inst_scores = None
        self.feat_scores = None

    def create_bkgnd_test_sets(self, shuffle_dataset=True):
        &#39;&#39;&#39;Distributes the data into background and test sets and returns
        the respective data tensors.

        Parameters
        ----------
        random_seed : integer, default 42
            Seed used when shuffling the data.
        shuffle_dataset : bool, default True
            If set to True, the data of which set is shuffled.

        Returns
        -------
        bkgnd_data : torch.Tensor, default None
            Background data used in the SHAP explainer to estimate conditional
            expectations.
        test_data : torch.Tensor, default None
            A subset of data on which model interpretation will be made (i.e.
            calculating feature and/or instance importance).
        &#39;&#39;&#39;
        # Create data indices for training and test splits
        dataset_size = self.data.shape[0]
        indices = list(range(dataset_size))
        if shuffle_dataset:
            # Shuffle data
            np.random.seed(self.random_seed)
            np.random.shuffle(indices)
        bkgnd_indices, test_indices = indices[:self.SHAP_bkgnd_samples], indices[self.SHAP_bkgnd_samples:]

        # Get separate tensors for the background data and the test data
        bkgnd_data = self.data[bkgnd_indices]
        test_data = self.data[test_indices]
        return bkgnd_data, test_data

    def mask_filter_step(self, mask, data, ref_output, l1_coeff=1,
                         hidden_state=None, debug_loss=False):
        &#39;&#39;&#39;Perform a single optimization step to calculate a new version of the
        mask filter.

        Parameters
        ----------
        mask : numpy.Array
            Current mask filter, either the initial one or from the previous
            optimization iteration.
        data : torch.Tensor
            Data sample which will be used to determine the most relevant
            features. In case of multivariate sequential data, this must be a
            single instance of a sequence.
        ref_output : torch.Tensor or float
            Model&#39;s output to the original instance, with no mask filters applied.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
            Hidden state coming from the previous recurrent cell. If none is
            specified, the hidden state is initialized as zero.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            optimization loss.

        Returns
        -------
        mask : numpy.Array
            Current mask filter, after the performed optimization step.

        if debug_loss is True:

        loss : float
            Current loss value of the mask filter optimization.
        &#39;&#39;&#39;
        # Get the model&#39;s output for the masked input data
        new_output = self.model((mask * data).unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
        # Calculate the loss function
        # • Minimize the number of activated mask filter units (occluded features)
        # • Maximize the change made to the output
        loss = l1_coeff * torch.mean(torch.abs(1 - mask)) + 1 - (ref_output - new_output).pow(2)
        # Backpropagate the loss function and run an optimization step (update the mask filter)
        loss.backward(retain_graph=True)
        mask.grad = du.deep_learning.change_grad((-1) * mask.grad, mask.data)
        mask.data = mask.data + mask.grad
        # Make sure that the mask has values either 0 or 1
        mask.data.clamp_(0, 1)
        mask.data.round_()
        if debug_loss:
            return mask, loss.item()
        else:
            return mask

    # [TODO] Confirm that the mask filter is working in every scenario
    def mask_filter(self, data=None, x_lengths=None, max_iter=100, l1_coeff=1,
                    lr=0.001, recur_layer=None, see_progress=True, debug_loss=False):
        &#39;&#39;&#39;Calculate a mask filter for the given data samples, through an
        appropriate optimization.

        Parameters
        ----------
        data : torch.Tensor, default None
            Data sample(s) which will be used to determine the most relevant
            features. In case of multivariate sequential data, each instance will
            be analyzed seperately. If None, all data known to the model
            interpreter will be used.
        x_lengths : list of int
            Sorted list of sequence lengths, relative to the input data.
        max_iter : int, default 100
            Maximum number of iterations of the mask filter optimization, for
            each instance.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        lr : float, default 0.001
            Learning rate used in the optimization algorithm.
        recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
            Pointer to the recurrent layer in the model, if it exists. It should
            either be a LSTM, GRU or RNN network. If none is specified, the
            method will automatically search for a recurrent layer in the model.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the feature importance scores calculations.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            optimization loss.

        Returns
        -------
        mask : numpy.Array
            Output mask, after finishing the optimization for every specified
            sample. It will be inverted before returning, so as to be an array
            filled with zeros, except in the indeces corresponding to the most
            relevant features, where it will be one.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        # [TODO] Work on an option to use input data different from multivariate sequential
        if data is None:
            # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
            data = self.data
        if x_lengths is None:
            # Sort the data by sequence length
            data, x_lengths = du.padding.sort_by_seq_len(data, self.seq_len_dict)
        if len(data.shape) &gt; 1 and recur_layer is None:
            # Search for a recurrent layer
            if hasattr(self.model, &#39;lstm&#39;):
                recur_layer = self.model.lstm
            elif hasattr(self.model, &#39;gru&#39;):
                recur_layer = self.model.gru
            elif hasattr(self.model, &#39;rnn&#39;):
                recur_layer = self.model.rnn
            else:
                raise Exception(&#39;ERROR: No recurrent layer found. Please specify it in the recur_layer argument.&#39;)

        # Confirm that the model is in evaluation mode to deactivate dropout
        self.model.eval()
        # Create a mask filter variable, initialized as an all ones tensor
        mask = torch.ones(data.shape)
        # [DEBUG] Create a loss matrix to analyse the convergence of mask filter optimizations
        loss_mtx = []

        if len(data.shape) == 3:
            # Loop to go through each sequence in the input data
            for seq in tqdm(range(data.shape[0]), disable=not see_progress):
                # Get the true length of the current sequence
                seq_len = x_lengths[seq]
                # Loop to go through each instance in the input sequence
                for inst in tqdm(range(seq_len), disable=not see_progress):
                    hidden_state = None
                    # Get the hidden state that the model receives as an input
                    if inst &gt; 0:
                        # Get the hidden state outputed from the previous recurrent cell
                        _, hidden_state = recur_layer(data[:inst])
                        # Avoid backpropagating through previous instances
                        if type(hidden_state) is tuple:
                            hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                        else:
                            hidden_state.detach_()
                    # Temporary mask filter for he current instance
                    tmp_mask = Variable(mask[seq, inst, :], requires_grad=True)
                    # [DEBUG] List of the current optimization&#39;s losses
                    tmp_loss_list = []
                    # Mask filter optimization loop
                    for iter in tqdm(range(max_iter), disable=not see_progress):
                        # Calculate the model&#39;s output to the original, unchanged instance data
                        ref_output = self.model(data[seq, inst, :].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                        # Prevent mask filter optimization from backpropagating through the reference output
                        ref_output.detach_()
                        # Perform a single optimization step
                        tmp_mask, tmp_loss = self.mask_filter_step(tmp_mask, data[seq, inst, :], ref_output, l1_coeff, hidden_state, debug_loss=debug_loss)
                        tmp_loss_list.append(tmp_loss)
                    # Save the optimized mask filter of the current instance
                    mask[seq, inst, :] = tmp_mask
                    # [DEBUG] Add the current instance&#39;s optimization logs to the overall loss matrix
                    loss_mtx.append(tmp_loss_list)

        elif len(data.shape) == 2:
            # Loop to go through each instance in the input sequence
            for inst in tqdm(range(data.shape[0]), disable=not see_progress):
                hidden_state = None
                # Get the hidden state that the model receives as an input
                if inst &gt; 0:
                    # Get the hidden state outputed from the previous recurrent cell
                    _, hidden_state = recur_layer(data[:inst])
                    # Avoid backpropagating through previous instances
                    if type(hidden_state) is tuple:
                        hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                    else:
                        hidden_state.detach_()
                # Temporary mask filter for he current instance
                tmp_mask = Variable(mask[inst], requires_grad=True)
                # Mask filter optimization loop
                for iter in tqdm(range(max_iter), disable=not see_progress):
                    # Calculate the model&#39;s output to the original, unchanged instance data
                    ref_output = self.model(data[inst].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                    # Prevent mask filter optimization from backpropagating through the reference output
                    ref_output.detach_()
                    # Perform a single optimization step
                    tmp_mask = self.mask_filter_step(tmp_mask, data[inst], ref_output, l1_coeff, hidden_state)
                # Save the optimized mask filter of the current instance
                mask[inst] = tmp_mask

        elif len(data.shape) == 1:
            # Make sure that the mask can be optimized properly
            mask.requires_grad_()
            # Mask filter optimization loop
            for iter in tqdm(range(max_iter), disable=not see_progress):
                # Calculate the model&#39;s output to the original, unchanged instance data
                ref_output = self.model(data.unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                # Prevent mask filter optimization from backpropagating through the reference output
                ref_output.detach_()
                # Perform a single optimization step
                mask = self.mask_filter_step(mask, data, ref_output, l1_coeff)

        else:
            raise Exception(f&#39;ERROR: Can\&#39;t handle data with more than 3 dimensions. Submitted data with {len(data.shape)} dimensions.&#39;)

        # Return the inverted version of the mask, to atrribute 1 (one) to the most relevant features
        if debug_loss:
            return 1 - mask, loss_mtx
        else:
            return 1 - mask

    def instance_importance(self, data=None, labels=None, x_lengths=None,
                            see_progress=True, occlusion_wgt=0.7):
        &#39;&#39;&#39;Calculate the instance importance scores to interpret the impact of
        each instance of a sequence on the final output.

        Parameters
        ----------
        data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance). Otherwise, all the data is used.
        labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        x_lengths : list of int
            Sorted list of sequence lengths, relative to the input data.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the instance importance scores calculations.
        occlusion_wgt : float, default 0.7
            Weight given to the occlusion part of the instance importance score.
            This scores is calculated as a weighted average of the instance&#39;s
            influence on the final output and the variation of the output
            probability, between the current instance and the previous one. As
            such, this weight should have a value between 0 and 1, with the
            output variation receiving the remaining weight (1 - occlusion_wgt),
            where 0 corresponds to not using the occlusion component at all, 0.5
            is a normal, unweighted average and 1 deactivates the use of the
            output variation part. If the value wasn&#39;t specified in the
            intepreter&#39;s initialization nor in the method argument, it will
            default to 0.7

        Returns
        -------
        inst_scores : numpy.Array
            Array containing the importance scores of each instance in the
            given input sequences.
        &#39;&#39;&#39;
        if occlusion_wgt is None:
            if self.occlusion_wgt is not None:
                # Set to the class&#39;s occlusion weight value
                occlusion_wgt = self.occlusion_wgt
            else:
                # Set the occlusion weight value to 0.7 (default)
                occlusion_wgt = 0.7
                self.occlusion_wgt = occlusion_wgt

        # Confirm that the occlusion weight has a valid value (between 0 and 1)
        if occlusion_wgt &gt; 1 or occlusion_wgt &lt; 0:
            raise Exception(f&#39;ERROR: Inserted invalid occlusion weight value {occlusion_wgt}. Please replace with a value between 0 and 1.&#39;)

        if occlusion_wgt &lt; 1:
            # If the output variation is used in the calculation of the score,
            # get the reference outputs for all the instances of the sequences
            seq_final_outputs = False
        else:
            # Otherwise, only the final outputs of the sequences are retrieved
            seq_final_outputs = True

        if data is None:
            # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
            data = self.data
            labels = self.labels
        # Make sure that the data is in type float
        data = data.float()
        # Model output when using all the original instances in the input sequences
        ref_output, _ = du.deep_learning.model_inference(self.model, data=(data, labels),
                                                         metrics=[&#39;&#39;], model_type=self.model_type,
                                                         is_custom=self.is_custom,
                                                         seq_len_dict=self.seq_len_dict,
                                                         padding_value=self.padding_value,
                                                         seq_final_outputs=seq_final_outputs,
                                                         cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                         already_embedded=self.already_embedded)

        if not seq_final_outputs:
            # Cumulative sequence lengths (true end of the sequences)
            final_seq_idx = np.cumsum(x_lengths)
            start_idx = np.roll(final_seq_idx, 1)
            start_idx[0] = 0
            ref_output = [ref_output[start_idx[i]:final_seq_idx[i]] for i in range(len(start_idx))]

        inst_scores = [[calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
                                            x_lengths[seq_num], occlusion_wgt, self.id_column_num,
                                            self.inst_column_num)
                        for inst in range(x_lengths[seq_num])] for seq_num in tqdm(range(data.shape[0]), disable=not see_progress)]
        # DEBUG
        # inst_scores = []
        # for seq_num in tqdm(range(data.shape[0]), disable=not see_progress):
        #     tmp_list = []
        #     for inst in range(x_lengths[seq_num]):
        #         tmp_list.append(calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
        #                                             x_lengths[seq_num], occlusion_wgt, self.id_column_num, self.inst_column_num))
        #     inst_scores.append(tmp_list)

        # Pad the instance scores lists so that all have the same length
        inst_scores = [du.padding.pad_list(scores_list, data.shape[1], padding_value=self.padding_value)
                       for scores_list in inst_scores]
        # Convert to a NumPy array
        inst_scores = np.array(inst_scores)
        return inst_scores

    def feature_importance(self, test_data=None, model_type=None,
                           method=&#39;shap&#39;, fast_calc=None, see_progress=True,
                           bkgnd_data=None, max_iter=100, l1_coeff=0, lr=0.001,
                           recur_layer=None, create_new_explainer=True, debug_loss=False,
                           total_length=None):
        &#39;&#39;&#39;Calculate the feature importance scores to interpret the impact
        of each feature in each instance&#39;s output.

        Parameters
        ----------
        test_data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance). Otherwise, all the data is used.
        model_type : string, default &#39;multivariate_rnn&#39;
            Sets the type of machine learning model. Important to know what type
            of inference and data processing to do. Currently available options
            are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
        method : string, defautl SHAP
            Defines which interpretability technique to use. Current options
            include SHAP Kernel Explainer (default) and mask filter.
        fast_calc : bool, default None
            If set to True, the algorithm uses less background samples (SHAP)
            or optimization steps (mask filter), in order to do a fast
            interpretation of the model. If set to False, the process takes
            more time in order to get a more precise and truthful
            interpretation of the model&#39;s behavior, requiring longer
            computation times.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the feature importance scores calculations.
        total_length : int, default None
            If not None, the feature importance scores will be padded to have
            length total_length.

        if fast_calc is False:

        bkgnd_data : torch.Tensor, default None
            In case of setting fast_calc to False, which makes the algorithm
            require background data in SHAP during the feature importance, the
            background data used in the explainer can be set through this
            parameter.

        if fast_calc is True:

        max_iter : int, default 100
            Maximum number of iterations of the mask filter optimization, for
            each instance.
        l1_coeff : int, default 1
            Weight given in the loss function to the L1 norm of the mask filter.
        lr : float, default 0.001
            Learning rate used in the optimization algorithm of the mask filter.
        recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
            Pointer to the recurrent layer in the model, if it exists. It should
            either be a LSTM, GRU or RNN network. If none is specified, the
            method will automatically search for a recurrent layer in the model.
        create_new_explainer : bool, default True
            Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
            previously defined one in the current model interpreter object.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            mask filter optimization loss.

        Returns
        -------
        feat_scores : numpy.Array
            Array containing the importance scores of each feature, of each
            instance, in the given input sequences.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        if fast_calc is None:
            # Use the predefined option if fast_calc isn&#39;t set in the function call
            fast_calc = self.fast_calc
        else:
            self.fast_calc = fast_calc
        if model_type is None:
            # Use the predefined option if model_type isn&#39;t set in the function call
            model_type = self.model_type
        else:
            self.model_type = model_type
        if total_length is None:
            # Use the predefined option if total_length isn&#39;t set in the function call
            total_length = self.total_length

        if model_type == &#39;multivariate_rnn&#39;:
            # Sort the test data by sequence length
            test_data, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict)
        # Set an indicator to log that the current model is a RNN
        isRNN = model_type == &#39;multivariate_rnn&#39;
        # Set an indicator to log that the current model is a bidirectional
        isBidir = self.model.bidir

        if method.lower() == &#39;shap&#39;:
            if create_new_explainer is True:
                # Go through all of the steps of initialiazing a new SHAP KernelExplainer
                if fast_calc:
                    print(f&#39;Attention: you have chosen to interpret the model using SHAP, with one background sample (all zeros), with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                    print(&#39;Evaluating the model with a reference value of zero. This should only be done if all the data is processed in a way that, for categorical features, 0 represents missing attribute and, for continuous features, 0 represents the average value of that feature.&#39;)
                    # Use a single all zeroes sample as a reference value
                    num_id_features = sum([1 if i is not None else 0 for i in [self.id_column_num, self.inst_column_num]])
                    bkgnd_data = np.zeros((1, len(self.feat_names) + num_id_features))
                else:
                    print(f&#39;Attention: you have chosen to interpret the model using SHAP, with {bkgnd_data.shape[0]} background samples, with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                    if model_type.lower() == &#39;multivariate_rnn&#39;:
                        # Sort the background data by sequence length
                        bkgnd_data, x_lengths_bkgnd = du.padding.sort_by_seq_len(bkgnd_data, self.seq_len_dict)
                        # Convert the background data into a 2D NumPy matrix
                        bkgnd_data = du.deep_learning.ts_tensor_to_np_matrix(bkgnd_data, self.feat_num, self.padding_value)
                    elif model_type.lower() == &#39;mlp&#39;:
                        # Just convert background data into a NumPy matrix
                        bkgnd_data = bkgnd_data.numpy()
                if model_type.lower() == &#39;multivariate_rnn&#39;:
                    # Convert the test data into a 2D NumPy matrix
                    test_data = du.deep_learning.ts_tensor_to_np_matrix(test_data, self.feat_num, self.padding_value)
                elif model_type.lower() == &#39;mlp&#39;:
                    # Remove ID columns from the data
                    bkgnd_data = du.deep_learning.remove_tensor_column(bkgnd_data, [self.id_column_num, self.inst_column_num], inplace=True)
                    test_data = du.deep_learning.remove_tensor_column(test_data, [self.id_column_num, self.inst_column_num], inplace=True)
                    # Convert test data into a NumPy matrix
                    test_data = test_data.numpy()
                # Create a function that represents the model&#39;s feedforward operation on a single instance
                kf = KernelFunction(self.model, model_type=model_type)
                # Use the background dataset to integrate over
                print(&#39;Creating a SHAP kernel explainer...&#39;)
                # [TODO] Removing this part of directly handling pure RNN models, as the `is_custom` parameter collides
                # with other definitions of it; ignoring for now as I&#39;m never using pure RNNs, without any modification
                # or at least wrapping in some class.
                # if self.is_custom is False:
                    # # Let SHAP find the recurrent layer
                    # recur_layer = None
                # else:
                # When using custom models, the whole model behaves as a recurrent layer
                # We just need to make sure that it returns the hidden state
                recur_layer = partial(self.model.forward, get_hidden_state=True)
                self.explainer = shap.KernelExplainer(kf.f, bkgnd_data, isRNN=isRNN, isBidir=isBidir,
                                                      model_obj=self.model, max_bkgnd_samples=100,
                                                      id_col_num=self.id_column_num,
                                                      ts_col_num=self.inst_column_num,
                                                      recur_layer=recur_layer)
            # Count the time that takes to calculate the SHAP values
            start_time = time.time()
            # Explain the predictions of the sequences in the test set
            print(&#39;Calculating feature importance scores for each instance in the test data...&#39;)
            feat_scores = self.explainer.shap_values(test_data, l1_reg=&#39;num_features(10)&#39;, nsamples=self.SHAP_bkgnd_samples, max_seq_len=total_length)
            print(f&#39;Calculation of SHAP values took {time.time() - start_time} seconds&#39;)
            return feat_scores

        else:
            # [TODO] Fix mask filter feature importance
            # [TODO] Add fast and slower versions of the mask filter
            # Remove identifier columns from the test data
            test_data = test_data[:, :, self.feat_num]
            # Make sure that the test data is in type float
            test_data = test_data.float()
            # Count the time that takes to calculate the SHAP values
            start_time = time.time()
            # Apply mask filter
            feat_scores, loss_mtx = self.mask_filter(test_data, x_lengths_test, max_iter,
                                                     l1_coeff, lr, recur_layer, debug_loss)
            print(f&#39;Calculation of mask filter values took {time.time() - start_time} seconds&#39;)
            if debug_loss:
                return feat_scores, loss_mtx
            else:
                return feat_scores
        # [TODO] Add more interpretability techniques, such as LIME and Agglomerative Contextual Decomposition (ACD)

    # [Bonus TODO] Upload model explainer and interpretability plots to Comet.ml
    def interpret_model(self, bkgnd_data=None, test_data=None, test_labels=None,
                        new_data=False, model_type=None, df=None,
                        instance_importance=True, feature_importance=False,
                        fast_calc=None, create_new_explainer=True,
                        see_progress=True, save_data=True, debug_loss=False,
                        total_length=None):
        &#39;&#39;&#39;Method to calculate scores of feature and/or instance importance, in
        order to be able to interpret a model on a given data.

        Parameters
        ----------
        bkgnd_data : torch.Tensor, default None
            In case of setting fast_calc to False, which makes the algorithm
            require background data in SHAP during the feature importance, the
            background data used in the explainer can be set through this
            parameter.
        test_data : torch.Tensor, default None
            Optionally, the user can specify a subset of data on which model
            interpretation will be made (i.e. calculating feature and/or
            instance importance) as a PyTorch tensor. Otherwise, all the data is
            used.
        test_labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        new_data : bool, default False
            If set to True, it indicates that the data that will be interpreted
            hasn&#39;t been seen before, i.e. it has different ids than those in the
            original dataset defined in the object initialization. This implies
            that a dataframe of the new data is provided (parameter df) so that
            the sequence lengths are calculated. Otherwise, the original
            sequence lengths known by the model interpreter are used.
        model_type : string, default None
            Sets the type of machine learning model. Important to know what type
            of inference and data processing to do. Currently available options
            are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
        df : pandas.DataFrame, default None
            Dataframe containing the new data so as to calculate the sequence
            lengths of the new ids. Only used if new_data is set to True and
            `model_type` is &#39;multivariate_rnn&#39;.
        instance_importance : bool, default True
            If set to True, instance importance is made on the data. In other
            words, the algorithm will analyze the impact that each instance of
            an input sequence had on the output.
        feature_importance : bool or string, default False
            Defines which feature importance interpretability technique to use.
            The algorithm will analyze the impact that each feature of
            an instance had on the output. This is analyzed instance by instance,
            not in the entire sequence at once. For example, from the feature
            importance alone, it&#39;s not straightforward how a value in a previous
            instance impacted the current output. Current options include SHAP
            Kernel Explainer (&#39;shap&#39;) and &#39;mask filter&#39;. If set to False, no
            feature importance will be done.
        fast_calc : bool, default None
            If set to True, the algorithm uses less background samples (SHAP)
            or optimization steps (mask filter), in order to do a fast
            interpretation of the model. If set to False, the process takes
            more time in order to get a more precise and truthful
            interpretation of the model&#39;s behavior, requiring longer
            computation times.
        create_new_explainer : bool, default True
            Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
            previously defined one in the current model interpreter object.
        see_progress : bool, default True
            If set to True, a progress bar will show up indicating the execution
            of the instance importance scores calculations.
        save_data : bool, default True
            If set to True, the possible background data (used in the SHAP
            explainer) and the test data (on which importance scores are
            calculated) are saved as object attributes.
        debug_loss : bool, default False
            Debugging flag, which makes the method also return an array of the
            mask filter optimization loss.
        total_length : int, default None
            If not None, the feature importance scores will be padded to have
            length total_length.

        Returns
        -------
        inst_scores : numpy.Array
            Array containing the importance scores of each instance in the
            given input sequences. Only calculated if instance_importance is set
            to True.
        feat_scores : numpy.Array
            Array containing the importance scores of each feature, of each
            instance, in the given input sequences. Only calculated if
            feature_importance is set to True.

        if debug_loss is True:

        loss_mtx : np.Array
            Matrix containing the loss values of the mask filter optimization.
        &#39;&#39;&#39;
        # Confirm that the model is in evaluation mode to deactivate dropout
        self.model.eval()

        if feature_importance is not None and feature_importance is not False:
            try:
                feature_importance = feature_importance.lower()
                if feature_importance != &#39;shap&#39; and feature_importance != &#39;mask filter&#39;:
                    raise Exception(f&#39;ERROR: Specified {feature_importance} feature importance method isn\&#39;t valid. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)
            except:
                raise Exception(f&#39;ERROR: {feature_importance} is an incorrectly defined feature importance method, as it should be a string. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)

        if fast_calc is None:
            # Use the predefined option if fast_calc isn&#39;t set in the function call
            fast_calc = self.fast_calc
        else:
            self.fast_calc = fast_calc
        if model_type is None:
            # Use the predefined option if model_type isn&#39;t set in the function call
            model_type = self.model_type
        else:
            self.model_type = model_type
        if total_length is None:
            # Use the predefined option if total_length isn&#39;t set in the function call
            total_length = self.total_length

        if test_labels is not None:
            if type(test_labels) is np.ndarray:
                # Convert from numpy to pytorch
                test_labels = torch.from_numpy(test_labels)

        if test_data is None:
            if fast_calc:
                # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
                test_data = self.data
                test_labels = self.labels
            else:
                if bkgnd_data is None:
                    # Get the background and test sets from the dataset
                    bkgnd_data, test_data = self.create_bkgnd_test_sets()
                else:
                    # Get the test set from the dataset
                    _, test_data = self.create_bkgnd_test_sets()
        elif type(test_data) is np.ndarray:
            # Convert from numpy to pytorch
            test_data = torch.from_numpy(test_data)

        if model_type == &#39;multivariate_rnn&#39;:
            if new_data is True:
                if df is None:
                    raise Exception(&#39;ERROR: A dataframe must be provided in order to work with the new data.&#39;)
                # Find the sequence lengths of the new data
                seq_len_dict = du.padding.get_sequence_length_dict(df, id_column=self.id_column_num, ts_column=self.inst_column_num)
                # Sort the data by sequence length
                test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, seq_len_dict, test_labels)
            else:
                # Sort the data by sequence length
                test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict, test_labels)

        if not fast_calc:
            if bkgnd_data is None:
                # Get the background set from the dataset
                bkgnd_data, _ = self.create_bkgnd_test_sets()
            elif type(bkgnd_data) is np.ndarray:
                # Convert from numpy to pytorch
                bkgnd_data = torch.from_numpy(bkgnd_data)

        if save_data:
            # Save the data used in the model interpretation
            self.bkgnd_data = bkgnd_data
            self.test_data = test_data
            self.test_labels = test_labels

        if instance_importance is True:
            print(&#39;Calculating instance importance scores...&#39;)
            # Calculate the scores of importance of each instance
            self.inst_scores = self.instance_importance(test_data, test_labels, x_lengths_test, see_progress)

        if feature_importance is not False:
            print(&#39;Calculating feature importance scores...&#39;)
            # Calculate the scores of importance of each feature in each instance
            if feature_importance == &#39;mask filter&#39; and debug_loss:
                self.feat_scores, loss_mtx = self.feature_importance(test_data, model_type,
                                                                     feature_importance,
                                                                     fast_calc, see_progress,
                                                                     bkgnd_data, debug_loss=True,
                                                                     total_length=total_length)
            else:
                self.feat_scores = self.feature_importance(test_data, model_type, feature_importance,
                                                           fast_calc, see_progress, bkgnd_data,
                                                           create_new_explainer=create_new_explainer,
                                                           debug_loss=False, total_length=total_length)

        print(&#39;Done!&#39;)

        if instance_importance and feature_importance:
            if fast_calc and debug_loss:
                return self.inst_scores, self.feat_scores, loss_mtx
            else:
                return self.inst_scores, self.feat_scores
        elif instance_importance and not feature_importance:
            return self.inst_scores
        elif not instance_importance and feature_importance:
            if fast_calc and debug_loss:
                return self.feat_scores, loss_mtx
            else:
                return self.feat_scores
        else:
            warnings.warn(&#39;Without setting instance_importance nor feature_importance to True, the interpret_model function won\&#39;t do anything relevant.&#39;)
            return


    def instance_importance_plot(self, orig_data=None, inst_scores=None, seq_id=None,
                                 pred_prob=None, uniform_spacing=False,
                                 show_pred_prob=True, show_title=True,
                                 show_colorbar=True, click_mode=&#39;event+select&#39;,
                                 labels=None, seq_len=None, threshold=0,
                                 get_fig_obj=False, tensor_idx=True,
                                 max_seq=10, background_color=&#39;white&#39;,
                                 font_family=&#39;Roboto&#39;, font_size=14,
                                 font_color=&#39;black&#39;):
        &#39;&#39;&#39;Create a bar chart that allows visualizing instance importance scores.

        Parameters
        ----------
        orig_data : torch.Tensor or numpy.Array, default None
            Original data used in the machine learning model. Used here to fetch
            the true ID corresponding to the plotted sequence.
        inst_scores : numpy.Array, default None
            Array containing the instance importance scores to be plotted.
        seq_id : int, default None
            ID or sequence index that select which time series / sequences to
            use in the plot. If it&#39;s a single value, the method plots a single
            sequence.
        pred_prob : numpy.Array or torch.Tensor or list of floats, default None
            Array containing the prediction probabilities for each sequence in
            the input data (orig_data). Only relevant if show_pred_prob is True.
        uniform_spacing : bool, default False
            Defines whether or not the sequences are displayed with uniform
            spacing (i.e. fixed distance) between their samples.
        show_pred_prob : bool, default True
            If set to True, a percentage bar chart will be shown to the right of
            the standard instance importance plot. If `pred_prob` isn&#39;t
            specified but the labels are, the prediction probabilities will be
            automatically calculated.
        show_title : bool, default True
            If set to True, the plot will have a title displayed above.
        show_colorbar : bool, default True
            If set to True, a bar legend will be shown, corresponding each color
            to each respective value.
        click_mode : string, default &#39;event+select&#39;
            Determines the mode of single click interactions. &#34;event&#34; is the
            default value and emits the `plotly_click` event. In addition this
            mode emits the `plotly_selected` event in drag modes &#34;lasso&#34; and
            &#34;select&#34;, but with no event data attached (kept for compatibility
            reasons). The &#34;select&#34; flag enables selecting single data points via
            click. This mode also supports persistent selections, meaning that
            pressing Shift while clicking, adds to / subtracts from an existing
            selection. &#34;select&#34; with `hovermode`: &#34;x&#34; can be confusing, consider
            explicitly setting `hovermode`: &#34;closest&#34; when using this feature.
            Selection events are sent accordingly as long as &#34;event&#34; flag is set
            as well. When the &#34;event&#34; flag is missing, `plotly_click` and
            `plotly_selected` events are not fired.
        labels : torch.Tensor, default None
            Labels corresponding to the data used, either specified in the input
            or all the data that the interpreter has.
        seq_len : int, default None
            Sequence lengths which represent the true, unpadded size of the
            input sequences.
        threshold : int or float, default 0
            Value to use as a threshold in the plot&#39;s color selection. In other
            words, values that exceed this threshold will have one color while the
            remaining have a different one, as specified in the parameters.
        get_fig_obj : bool, default False
            If set to True, the function returns the object that contains the
            displayed plotly figure.
        tensor_idx : bool, default True
            If set to True, the ID specified in the respective parameter
            constitutes the index where the desired sequence resides. Otherwise,
            it&#39;s the actual unique identifier that appears in the original data.
        max_seq : int, default 10
            Maximum number of sequences to show in the plot. This is meant to
            prevent cramming too many sequences into the graph window.
        background_color : str, default &#39;white&#39;
            The plot&#39;s background color. Can be set in color name (e.g. &#39;white&#39;),
            hexadecimal code (e.g. &#39;#555&#39;) or RGB (e.g. &#39;rgb(0,0,255)&#39;).
        font_family : str, default &#39;Roboto&#39;
            Text font family to be used in the numbers shown next to the graph.
        font_size : int, default 14
            Text font size to be used in the numbers shown next to the graph.
        font_color : str, default &#39;black&#39;
            Text font color to be used in the numbers shown next to the graph. Can
            be set in color name (e.g. &#39;white&#39;), hexadecimal code (e.g. &#39;#555&#39;) or
            GB (e.g. &#39;rgb(0,0,255)&#39;).

        Returns
        -------
        fig : plotly.graph_objs.Figure or None
            If argument get_fig_obj is set to True, the figure object is returned.
            Otherwise, nothing is returned, only the plot is showned.&#39;&#39;&#39;
        if orig_data is None:
            # Use all the data if none was specified
            orig_data = self.data

            if labels is None:
                labels = self.labels

        if inst_scores is None:
            if self.inst_scores is None:
                raise Exception(&#39;ERROR: No instance importance scores found. If the scores aren\&#39;t specified, then they must have already been calculated through the interpret_model method.&#39;)
            # Use all the previously calculated scores if none were specified
            inst_scores = self.inst_scores

        # Plot the instance importance of multiple sequences
        # Convert the instance scores data into a NumPy array
        if type(inst_scores) is torch.Tensor:
            inst_scores = inst_scores.detach().numpy()
        elif type(inst_scores) is list:
            inst_scores = np.array(inst_scores)

        # if is not tensor_idx:
        # [TODO] Search for the index associated to the specific ID asked for by the user
        # [TODO] Allow to search for multiple indeces and generate a multiple patients time series plot from it

        if len(inst_scores.shape) == 1 or (seq_id is not None and type(seq_id) is not list):
            # True sequence length of the current id&#39;s data
            if seq_len is None:
                seq_len = self.seq_len_dict[orig_data[seq_id, 0, self.id_column_num].item()]

            # [TODO] Add a prediction probability bar plot like in the multiple sequences case

            # Plot the instance importance of one sequence
            plot_data = [go.Bar(
                            x = list(range(seq_len)),
                            y = inst_scores[seq_id, :seq_len],
                            marker=dict(color=du.utils.set_bar_color(inst_scores, seq_id, seq_len,
                                                                     threshold=threshold,
                                                                     pos_color=POS_COLOR,
                                                                     neg_color=NEG_COLOR))
                          )]
            layout = go.Layout(
                                title=f&#39;Instance importance scores for ID {int(orig_data[id, 0, self.id_column_num])}&#39;,
                                xaxis=dict(title=&#39;Instance&#39;),
                                yaxis=dict(title=&#39;Importance scores&#39;)
                              )
        else:
            if seq_id is None:
                # Use all the sequences data if a subset isn&#39;t specified
                seq_id = list(range(inst_scores.shape[0]))
            # Select the desired data according to the specified IDs
            inst_scores = inst_scores[seq_id, :]
            orig_data = orig_data[seq_id, :, :]
            # Unique patient IDs in string format
            patients = [str(int(item)) for item in [tensor.item()
                        for tensor in list(orig_data[:, 0, self.id_column_num])]]
            if uniform_spacing is True:
                # Sequence instances count, used as X in the plot
                seq_insts_x = [list(range(inst_scores.shape[1]))
                               for patient in range(len(patients))]
            else:
                # Use the original timestamp values as the X axis
                seq_insts_x = [int(tensor) for seq_list
                               in [list(ts_array) for ts_array in list(orig_data[:, :, self.inst_column_num])]
                               for tensor in seq_list]
            # Patients ids repeated max sequence length times, used as Y in the plot
            patients_y = [[patient]*inst_scores.shape[1] for patient in list(patients)]
            # Flatten seq_insts and patients_y
            seq_insts_x = list(np.array(seq_insts_x).flatten())
            patients_y = list(np.array(patients_y).flatten())
            # Define colors for the data points based on their normalized scores (from 0 to 1 instead of -1 to 1)
            colors = [val for val in inst_scores.flatten()]
            # Count the number of already deleted paddings
            count = 0

            for i in range(inst_scores.shape[0]):
                for j in range(inst_scores.shape[1]):
                    if inst_scores[i, j] == self.padding_value:
                        # Delete elements that represent paddings, not real instances
                        del seq_insts_x[i*inst_scores.shape[1]+j-count]
                        del patients_y[i*inst_scores.shape[1]+j-count]
                        del colors[i*inst_scores.shape[1]+j-count]
                        # Increment the counting of already deleted items
                        count += 1

            if show_pred_prob is True:
                if pred_prob is None:
                    if labels is None:
                        raise Exception(&#39;ERROR: By setting `show_pred_prob` to True, either the prediction probabilities (pred_prob) or the labels must be provided.&#39;)
                    # Calculate the prediction probabilities for the provided data
                    pred_prob, _ = du.deep_learning.model_inference(self.model, data=(orig_data, labels),
                                                                    metrics=[&#39;&#39;], model_type=self.model_type,
                                                                    is_custom=self.is_custom,
                                                                    seq_len_dict=self.seq_len_dict,
                                                                    padding_value=self.padding_value,
                                                                    output_rounded=False,
                                                                    seq_final_outputs=True,
                                                                    cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                                    already_embedded=self.already_embedded)
                # Convert the prediction probability data into a NumPy array
                if type(pred_prob) is torch.Tensor:
                    pred_prob = pred_prob.detach().numpy()
                elif type(pred_prob) is list:
                    pred_prob = np.array(pred_prob)
                # Select the desired data according to the specified IDs
                pred_prob = pred_prob[seq_id]
                # Colors to use in the prediction probability bar plots
                pred_colors = cl.scales[&#39;8&#39;][&#39;div&#39;][&#39;RdYlGn&#39;]
                # Create &#34;percentage bar&#34; plots through pairs of unfilled and filled rectangles
                shapes_list = []
                # Starting y coordinate of the first shape
                y0 = -0.25
                # Height of the shapes (y length)
                step = 0.5
                # Maximum width of the shapes
                max_width = 1
                for i in range(len(patients)):
                    # Set the starting x coordinate to after the last data point
                    x0 = inst_scores.shape[1]
                    # Set the filling length of the shape
                    x1_fill = x0 + pred_prob[i] * max_width
                    shape_unfilled = {
                                        &#39;type&#39;: &#39;rect&#39;,
                                        &#39;x0&#39;: x0,
                                        &#39;y0&#39;: y0,
                                        &#39;x1&#39;: x0 + max_width,
                                        &#39;y1&#39;: y0 + step,
                                        &#39;line&#39;: {
                                                    &#39;color&#39;: &#39;rgba(0, 0, 0, 1)&#39;,
                                                    &#39;width&#39;: 2,
                                                },
                                    }
                    shape_filled = {
                                        &#39;type&#39;: &#39;rect&#39;,
                                        &#39;x0&#39;: x0,
                                        &#39;y0&#39;: y0,
                                        &#39;x1&#39;: x1_fill,
                                        &#39;y1&#39;: y0 + step,
                                        &#39;fillcolor&#39;: pred_colors[int(len(pred_colors)-1-max(pred_prob[i]*len(pred_colors)-1, 0))]
                                    }
                    shapes_list.append(shape_unfilled)
                    shapes_list.append(shape_filled)
                    # Set the starting y coordinate for the next shapes
                    y0 = y0 + 2 * step

                # Getting points along the percentage bar plots
                x_range = [list(np.array(range(0, 10, 1))*0.1+inst_scores.shape[1]) for idx in range(len(patients))]
                # Flatten the list
                text_x = [item for sublist in x_range for item in sublist]
                # Y coordinates of the prediction probability text
                text_y = [patient for patient in patients for idx in range(10)]
                # Prediction probabilities in text form, to appear in the plot
                text_content = [pred_prob[idx] for idx in range(len(pred_prob)) for i in range(10)]
                # [TODO] Ajdust the zoom so that the initial plot doens&#39;t block part of the first and last sequences that show up

            # Create plotly chart
            plot_data = [dict(
                x=seq_insts_x,
                y=patients_y,
                marker=dict(
                    color=colors,
                    size=12,
                    line = dict(
                        color = &#39;black&#39;,
                        width = 1
                    ),
                    colorscale=[[0, &#39;rgba(30,136,229,1)&#39;], [0.5, &#39;white&#39;], [1, &#39;rgba(255,13,87,1)&#39;]],
                    cmax=1,
                    cmin=-1,
                ),
                mode=&#39;markers&#39;,
                type=&#39;scatter&#39;,
                hoverinfo=&#39;x+y&#39;
            )]
            layout = dict(
                paper_bgcolor=background_color,
                plot_bgcolor=background_color,
                font=dict(
                    family=font_family,
                    size=font_size,
                    color=font_color
                ),
                xaxis=dict(
                    title=&#39;Instance&#39;,
                    showgrid=False,
                    zeroline=False
                ),
                yaxis=dict(
                    title=&#39;Patient ID&#39;,
                    showgrid=False,
                    zeroline=False,
                    type=&#39;category&#39;
                ),
                hovermode=&#39;closest&#39;,
                showlegend=False,
                clickmode=click_mode
            )
            if show_title is True:
                layout[&#39;title&#39;] = &#39;Instance importance&#39;
                layout[&#39;margin&#39;] = dict(l=0, r=0, t=30, b=0, pad=0)
            else:
                layout[&#39;margin&#39;] = dict(l=0, r=0, t=0, b=0, pad=0)
            if show_colorbar is True:
                layout[&#39;meta&#39;] = dict()
                layout[&#39;meta&#39;][&#39;colorbar&#39;] = dict(title=&#39;Scores&#39;)
            if show_pred_prob is True:
                # Add hover text to indicate the final output probabilities
                prob_hover_info = go.Scatter(
                    x=text_x,
                    y=text_y,
                    text=text_content,
                    mode=&#39;text&#39;,
                    textfont=dict(size = 1, color=&#39;#ffffff&#39;),
                    hoverinfo=&#39;y+text&#39;
                )
                plot_data.append(prob_hover_info)
                # Add final output probabilities bar plots
                layout[&#39;shapes&#39;] = shapes_list
            if len(patients) &gt; max_seq:
                # Prevent cramming too many sequences into the plot
                layout[&#39;yaxis&#39;][&#39;range&#39;] = [patients[max_seq], patients[0]]
        # Show the plot
        fig = go.Figure(plot_data, layout)

        if get_fig_obj:
            # Only return the figure object if specified by the user
            return fig
        else:
            py.iplot(fig)
            return

    # [TODO] Develop function to explain, in text form, why a given input data has a certain output.
    # The results gather with instance and feature importance, as well as counter-examples, should
    # be used.
    # def explain_output(self, data, detailed_explanation=True):
        # if detailed_explanation:
        #     inst_scores, feat_scores = self.interpret_model(test_data=data, instance_importance=True,
        #                                                     feature_importance=True, fast_calc=False)
        #
            # [TODO] Explain the most important instances and most important features on those instances
            # [TODO] Compare with counter-examples, i.e. cases where the classification was different
        # else:
        #     inst_scores, feat_scores = self.interpret_model(test_data=data, instance_importance=True,
        #                                                     feature_importance=True, fast_calc=True)
        #
            # [TODO] Explain the most important instances and most important features on those instances

    # [TODO] Define an automatic method to discover which embedded category was more
    # important by doing inference on individual embeddings of each category separately,
    # seeing which one caused a bigger change in the output.

    def shap_values_df(self):
        &#39;&#39;&#39;Create a dataframe that contains both the original data used in the
        interpretation of the model and the resulting SHAP values.

        Returns
        -------
        data_n_shap_df : pandas.DataFrame
            Dataframe that contains both the original data used in the
            interpretation of the model and the resulting SHAP values.&#39;&#39;&#39;
        # [TODO] Add option to handle pre-calculated SHAP values
        # (pre-defined data and SHAP values, outside of the Model Interpreter)
        # Join the original data and the features&#39; SHAP values
        data_n_shap = np.concatenate([self.test_data.numpy(), self.test_labels.unsqueeze(2).numpy(), self.feat_scores], axis=2)
        # Reshape into a 2D format
        data_n_shap = data_n_shap.reshape(-1, data_n_shap.shape[-1])
        # Remove padding samples
        data_n_shap = data_n_shap[[self.padding_value not in row for row in data_n_shap]]
        # Define the column names list
        shap_column_names = [f&#39;{feature}_shap&#39; for feature in self.feat_names]
        column_names = ([self.id_column_name] + [self.inst_column_name] + self.feat_names
                        + [self.label_column_name] + shap_column_names)
        # Create the dataframe
        data_n_shap_df = pd.DataFrame(data=data_n_shap, columns=column_names)
        return data_n_shap_df</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.create_bkgnd_test_sets"><code class="name flex">
<span>def <span class="ident">create_bkgnd_test_sets</span></span>(<span>self, shuffle_dataset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Distributes the data into background and test sets and returns
the respective data tensors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>random_seed</code></strong> :&ensp;<code>integer</code>, default <code>42</code></dt>
<dd>Seed used when shuffling the data.</dd>
<dt><strong><code>shuffle_dataset</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the data of which set is shuffled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bkgnd_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Background data used in the SHAP explainer to estimate conditional
expectations.</dd>
<dt><strong><code>test_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>A subset of data on which model interpretation will be made (i.e.
calculating feature and/or instance importance).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bkgnd_test_sets(self, shuffle_dataset=True):
    &#39;&#39;&#39;Distributes the data into background and test sets and returns
    the respective data tensors.

    Parameters
    ----------
    random_seed : integer, default 42
        Seed used when shuffling the data.
    shuffle_dataset : bool, default True
        If set to True, the data of which set is shuffled.

    Returns
    -------
    bkgnd_data : torch.Tensor, default None
        Background data used in the SHAP explainer to estimate conditional
        expectations.
    test_data : torch.Tensor, default None
        A subset of data on which model interpretation will be made (i.e.
        calculating feature and/or instance importance).
    &#39;&#39;&#39;
    # Create data indices for training and test splits
    dataset_size = self.data.shape[0]
    indices = list(range(dataset_size))
    if shuffle_dataset:
        # Shuffle data
        np.random.seed(self.random_seed)
        np.random.shuffle(indices)
    bkgnd_indices, test_indices = indices[:self.SHAP_bkgnd_samples], indices[self.SHAP_bkgnd_samples:]

    # Get separate tensors for the background data and the test data
    bkgnd_data = self.data[bkgnd_indices]
    test_data = self.data[test_indices]
    return bkgnd_data, test_data</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.feature_importance"><code class="name flex">
<span>def <span class="ident">feature_importance</span></span>(<span>self, test_data=None, model_type=None, method='shap', fast_calc=None, see_progress=True, bkgnd_data=None, max_iter=100, l1_coeff=0, lr=0.001, recur_layer=None, create_new_explainer=True, debug_loss=False, total_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the feature importance scores to interpret the impact
of each feature in each instance's output.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>test_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Optionally, the user can specify a subset of data on which model
interpretation will be made (i.e. calculating feature and/or
instance importance). Otherwise, all the data is used.</dd>
<dt><strong><code>model_type</code></strong> :&ensp;<code>string</code>, default <code>'multivariate_rnn'</code></dt>
<dd>Sets the type of machine learning model. Important to know what type
of inference and data processing to do. Currently available options
are ['multivariate_rnn', 'mlp'].</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string, defautl SHAP</code></dt>
<dd>Defines which interpretability technique to use. Current options
include SHAP Kernel Explainer (default) and mask filter.</dd>
<dt><strong><code>fast_calc</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>If set to True, the algorithm uses less background samples (SHAP)
or optimization steps (mask filter), in order to do a fast
interpretation of the model. If set to False, the process takes
more time in order to get a more precise and truthful
interpretation of the model's behavior, requiring longer
computation times.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the feature importance scores calculations.</dd>
<dt><strong><code>total_length</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>If not None, the feature importance scores will be padded to have
length total_length.</dd>
</dl>
<p>if fast_calc is False:</p>
<dl>
<dt><strong><code>bkgnd_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>In case of setting fast_calc to False, which makes the algorithm
require background data in SHAP during the feature importance, the
background data used in the explainer can be set through this
parameter.</dd>
</dl>
<p>if fast_calc is True:</p>
<dl>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code>, default <code>100</code></dt>
<dd>Maximum number of iterations of the mask filter optimization, for
each instance.</dd>
<dt><strong><code>l1_coeff</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Weight given in the loss function to the L1 norm of the mask filter.</dd>
<dt><strong><code>lr</code></strong> :&ensp;<code>float</code>, default <code>0.001</code></dt>
<dd>Learning rate used in the optimization algorithm of the mask filter.</dd>
<dt><strong><code>recur_layer</code></strong> :&ensp;<code>torch.nn.LSTM</code> or <code>torch.nn.GRU</code> or <code>torch.nn.RNN</code>, default <code>None</code></dt>
<dd>Pointer to the recurrent layer in the model, if it exists. It should
either be a LSTM, GRU or RNN network. If none is specified, the
method will automatically search for a recurrent layer in the model.</dd>
<dt><strong><code>create_new_explainer</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Sets if we'll create a new SHAP KernelExplainer or if we'll use a
previously defined one in the current model interpreter object.</dd>
<dt><strong><code>debug_loss</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Debugging flag, which makes the method also return an array of the
mask filter optimization loss.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feat_scores</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Array containing the importance scores of each feature, of each
instance, in the given input sequences.</dd>
<dt><code>if debug_loss is True:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>loss_mtx</code></strong> :&ensp;<code>np.Array</code></dt>
<dd>Matrix containing the loss values of the mask filter optimization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feature_importance(self, test_data=None, model_type=None,
                       method=&#39;shap&#39;, fast_calc=None, see_progress=True,
                       bkgnd_data=None, max_iter=100, l1_coeff=0, lr=0.001,
                       recur_layer=None, create_new_explainer=True, debug_loss=False,
                       total_length=None):
    &#39;&#39;&#39;Calculate the feature importance scores to interpret the impact
    of each feature in each instance&#39;s output.

    Parameters
    ----------
    test_data : torch.Tensor, default None
        Optionally, the user can specify a subset of data on which model
        interpretation will be made (i.e. calculating feature and/or
        instance importance). Otherwise, all the data is used.
    model_type : string, default &#39;multivariate_rnn&#39;
        Sets the type of machine learning model. Important to know what type
        of inference and data processing to do. Currently available options
        are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
    method : string, defautl SHAP
        Defines which interpretability technique to use. Current options
        include SHAP Kernel Explainer (default) and mask filter.
    fast_calc : bool, default None
        If set to True, the algorithm uses less background samples (SHAP)
        or optimization steps (mask filter), in order to do a fast
        interpretation of the model. If set to False, the process takes
        more time in order to get a more precise and truthful
        interpretation of the model&#39;s behavior, requiring longer
        computation times.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the feature importance scores calculations.
    total_length : int, default None
        If not None, the feature importance scores will be padded to have
        length total_length.

    if fast_calc is False:

    bkgnd_data : torch.Tensor, default None
        In case of setting fast_calc to False, which makes the algorithm
        require background data in SHAP during the feature importance, the
        background data used in the explainer can be set through this
        parameter.

    if fast_calc is True:

    max_iter : int, default 100
        Maximum number of iterations of the mask filter optimization, for
        each instance.
    l1_coeff : int, default 1
        Weight given in the loss function to the L1 norm of the mask filter.
    lr : float, default 0.001
        Learning rate used in the optimization algorithm of the mask filter.
    recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
        Pointer to the recurrent layer in the model, if it exists. It should
        either be a LSTM, GRU or RNN network. If none is specified, the
        method will automatically search for a recurrent layer in the model.
    create_new_explainer : bool, default True
        Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
        previously defined one in the current model interpreter object.
    debug_loss : bool, default False
        Debugging flag, which makes the method also return an array of the
        mask filter optimization loss.

    Returns
    -------
    feat_scores : numpy.Array
        Array containing the importance scores of each feature, of each
        instance, in the given input sequences.

    if debug_loss is True:

    loss_mtx : np.Array
        Matrix containing the loss values of the mask filter optimization.
    &#39;&#39;&#39;
    if fast_calc is None:
        # Use the predefined option if fast_calc isn&#39;t set in the function call
        fast_calc = self.fast_calc
    else:
        self.fast_calc = fast_calc
    if model_type is None:
        # Use the predefined option if model_type isn&#39;t set in the function call
        model_type = self.model_type
    else:
        self.model_type = model_type
    if total_length is None:
        # Use the predefined option if total_length isn&#39;t set in the function call
        total_length = self.total_length

    if model_type == &#39;multivariate_rnn&#39;:
        # Sort the test data by sequence length
        test_data, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict)
    # Set an indicator to log that the current model is a RNN
    isRNN = model_type == &#39;multivariate_rnn&#39;
    # Set an indicator to log that the current model is a bidirectional
    isBidir = self.model.bidir

    if method.lower() == &#39;shap&#39;:
        if create_new_explainer is True:
            # Go through all of the steps of initialiazing a new SHAP KernelExplainer
            if fast_calc:
                print(f&#39;Attention: you have chosen to interpret the model using SHAP, with one background sample (all zeros), with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                print(&#39;Evaluating the model with a reference value of zero. This should only be done if all the data is processed in a way that, for categorical features, 0 represents missing attribute and, for continuous features, 0 represents the average value of that feature.&#39;)
                # Use a single all zeroes sample as a reference value
                num_id_features = sum([1 if i is not None else 0 for i in [self.id_column_num, self.inst_column_num]])
                bkgnd_data = np.zeros((1, len(self.feat_names) + num_id_features))
            else:
                print(f&#39;Attention: you have chosen to interpret the model using SHAP, with {bkgnd_data.shape[0]} background samples, with {self.SHAP_bkgnd_samples} reevalutions per prediction applied to {test_data.shape[0]} test samples. This might take a while. Depending on your computer\&#39;s processing power, you should do a coffee break or even go to sleep!&#39;)
                if model_type.lower() == &#39;multivariate_rnn&#39;:
                    # Sort the background data by sequence length
                    bkgnd_data, x_lengths_bkgnd = du.padding.sort_by_seq_len(bkgnd_data, self.seq_len_dict)
                    # Convert the background data into a 2D NumPy matrix
                    bkgnd_data = du.deep_learning.ts_tensor_to_np_matrix(bkgnd_data, self.feat_num, self.padding_value)
                elif model_type.lower() == &#39;mlp&#39;:
                    # Just convert background data into a NumPy matrix
                    bkgnd_data = bkgnd_data.numpy()
            if model_type.lower() == &#39;multivariate_rnn&#39;:
                # Convert the test data into a 2D NumPy matrix
                test_data = du.deep_learning.ts_tensor_to_np_matrix(test_data, self.feat_num, self.padding_value)
            elif model_type.lower() == &#39;mlp&#39;:
                # Remove ID columns from the data
                bkgnd_data = du.deep_learning.remove_tensor_column(bkgnd_data, [self.id_column_num, self.inst_column_num], inplace=True)
                test_data = du.deep_learning.remove_tensor_column(test_data, [self.id_column_num, self.inst_column_num], inplace=True)
                # Convert test data into a NumPy matrix
                test_data = test_data.numpy()
            # Create a function that represents the model&#39;s feedforward operation on a single instance
            kf = KernelFunction(self.model, model_type=model_type)
            # Use the background dataset to integrate over
            print(&#39;Creating a SHAP kernel explainer...&#39;)
            # [TODO] Removing this part of directly handling pure RNN models, as the `is_custom` parameter collides
            # with other definitions of it; ignoring for now as I&#39;m never using pure RNNs, without any modification
            # or at least wrapping in some class.
            # if self.is_custom is False:
                # # Let SHAP find the recurrent layer
                # recur_layer = None
            # else:
            # When using custom models, the whole model behaves as a recurrent layer
            # We just need to make sure that it returns the hidden state
            recur_layer = partial(self.model.forward, get_hidden_state=True)
            self.explainer = shap.KernelExplainer(kf.f, bkgnd_data, isRNN=isRNN, isBidir=isBidir,
                                                  model_obj=self.model, max_bkgnd_samples=100,
                                                  id_col_num=self.id_column_num,
                                                  ts_col_num=self.inst_column_num,
                                                  recur_layer=recur_layer)
        # Count the time that takes to calculate the SHAP values
        start_time = time.time()
        # Explain the predictions of the sequences in the test set
        print(&#39;Calculating feature importance scores for each instance in the test data...&#39;)
        feat_scores = self.explainer.shap_values(test_data, l1_reg=&#39;num_features(10)&#39;, nsamples=self.SHAP_bkgnd_samples, max_seq_len=total_length)
        print(f&#39;Calculation of SHAP values took {time.time() - start_time} seconds&#39;)
        return feat_scores

    else:
        # [TODO] Fix mask filter feature importance
        # [TODO] Add fast and slower versions of the mask filter
        # Remove identifier columns from the test data
        test_data = test_data[:, :, self.feat_num]
        # Make sure that the test data is in type float
        test_data = test_data.float()
        # Count the time that takes to calculate the SHAP values
        start_time = time.time()
        # Apply mask filter
        feat_scores, loss_mtx = self.mask_filter(test_data, x_lengths_test, max_iter,
                                                 l1_coeff, lr, recur_layer, debug_loss)
        print(f&#39;Calculation of mask filter values took {time.time() - start_time} seconds&#39;)
        if debug_loss:
            return feat_scores, loss_mtx
        else:
            return feat_scores</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.instance_importance"><code class="name flex">
<span>def <span class="ident">instance_importance</span></span>(<span>self, data=None, labels=None, x_lengths=None, see_progress=True, occlusion_wgt=0.7)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the instance importance scores to interpret the impact of
each instance of a sequence on the final output.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Optionally, the user can specify a subset of data on which model
interpretation will be made (i.e. calculating feature and/or
instance importance). Otherwise, all the data is used.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Labels corresponding to the data used, either specified in the input
or all the data that the interpreter has.</dd>
<dt><strong><code>x_lengths</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Sorted list of sequence lengths, relative to the input data.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the instance importance scores calculations.</dd>
<dt><strong><code>occlusion_wgt</code></strong> :&ensp;<code>float</code>, default <code>0.7</code></dt>
<dd>Weight given to the occlusion part of the instance importance score.
This scores is calculated as a weighted average of the instance's
influence on the final output and the variation of the output
probability, between the current instance and the previous one. As
such, this weight should have a value between 0 and 1, with the
output variation receiving the remaining weight (1 - occlusion_wgt),
where 0 corresponds to not using the occlusion component at all, 0.5
is a normal, unweighted average and 1 deactivates the use of the
output variation part. If the value wasn't specified in the
intepreter's initialization nor in the method argument, it will
default to 0.7</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inst_scores</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Array containing the importance scores of each instance in the
given input sequences.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instance_importance(self, data=None, labels=None, x_lengths=None,
                        see_progress=True, occlusion_wgt=0.7):
    &#39;&#39;&#39;Calculate the instance importance scores to interpret the impact of
    each instance of a sequence on the final output.

    Parameters
    ----------
    data : torch.Tensor, default None
        Optionally, the user can specify a subset of data on which model
        interpretation will be made (i.e. calculating feature and/or
        instance importance). Otherwise, all the data is used.
    labels : torch.Tensor, default None
        Labels corresponding to the data used, either specified in the input
        or all the data that the interpreter has.
    x_lengths : list of int
        Sorted list of sequence lengths, relative to the input data.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the instance importance scores calculations.
    occlusion_wgt : float, default 0.7
        Weight given to the occlusion part of the instance importance score.
        This scores is calculated as a weighted average of the instance&#39;s
        influence on the final output and the variation of the output
        probability, between the current instance and the previous one. As
        such, this weight should have a value between 0 and 1, with the
        output variation receiving the remaining weight (1 - occlusion_wgt),
        where 0 corresponds to not using the occlusion component at all, 0.5
        is a normal, unweighted average and 1 deactivates the use of the
        output variation part. If the value wasn&#39;t specified in the
        intepreter&#39;s initialization nor in the method argument, it will
        default to 0.7

    Returns
    -------
    inst_scores : numpy.Array
        Array containing the importance scores of each instance in the
        given input sequences.
    &#39;&#39;&#39;
    if occlusion_wgt is None:
        if self.occlusion_wgt is not None:
            # Set to the class&#39;s occlusion weight value
            occlusion_wgt = self.occlusion_wgt
        else:
            # Set the occlusion weight value to 0.7 (default)
            occlusion_wgt = 0.7
            self.occlusion_wgt = occlusion_wgt

    # Confirm that the occlusion weight has a valid value (between 0 and 1)
    if occlusion_wgt &gt; 1 or occlusion_wgt &lt; 0:
        raise Exception(f&#39;ERROR: Inserted invalid occlusion weight value {occlusion_wgt}. Please replace with a value between 0 and 1.&#39;)

    if occlusion_wgt &lt; 1:
        # If the output variation is used in the calculation of the score,
        # get the reference outputs for all the instances of the sequences
        seq_final_outputs = False
    else:
        # Otherwise, only the final outputs of the sequences are retrieved
        seq_final_outputs = True

    if data is None:
        # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
        data = self.data
        labels = self.labels
    # Make sure that the data is in type float
    data = data.float()
    # Model output when using all the original instances in the input sequences
    ref_output, _ = du.deep_learning.model_inference(self.model, data=(data, labels),
                                                     metrics=[&#39;&#39;], model_type=self.model_type,
                                                     is_custom=self.is_custom,
                                                     seq_len_dict=self.seq_len_dict,
                                                     padding_value=self.padding_value,
                                                     seq_final_outputs=seq_final_outputs,
                                                     cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                     already_embedded=self.already_embedded)

    if not seq_final_outputs:
        # Cumulative sequence lengths (true end of the sequences)
        final_seq_idx = np.cumsum(x_lengths)
        start_idx = np.roll(final_seq_idx, 1)
        start_idx[0] = 0
        ref_output = [ref_output[start_idx[i]:final_seq_idx[i]] for i in range(len(start_idx))]

    inst_scores = [[calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
                                        x_lengths[seq_num], occlusion_wgt, self.id_column_num,
                                        self.inst_column_num)
                    for inst in range(x_lengths[seq_num])] for seq_num in tqdm(range(data.shape[0]), disable=not see_progress)]
    # DEBUG
    # inst_scores = []
    # for seq_num in tqdm(range(data.shape[0]), disable=not see_progress):
    #     tmp_list = []
    #     for inst in range(x_lengths[seq_num]):
    #         tmp_list.append(calc_instance_score(self.model, data[seq_num, :, :], inst, ref_output[seq_num],
    #                                             x_lengths[seq_num], occlusion_wgt, self.id_column_num, self.inst_column_num))
    #     inst_scores.append(tmp_list)

    # Pad the instance scores lists so that all have the same length
    inst_scores = [du.padding.pad_list(scores_list, data.shape[1], padding_value=self.padding_value)
                   for scores_list in inst_scores]
    # Convert to a NumPy array
    inst_scores = np.array(inst_scores)
    return inst_scores</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.instance_importance_plot"><code class="name flex">
<span>def <span class="ident">instance_importance_plot</span></span>(<span>self, orig_data=None, inst_scores=None, seq_id=None, pred_prob=None, uniform_spacing=False, show_pred_prob=True, show_title=True, show_colorbar=True, click_mode='event+select', labels=None, seq_len=None, threshold=0, get_fig_obj=False, tensor_idx=True, max_seq=10, background_color='white', font_family='Roboto', font_size=14, font_color='black')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a bar chart that allows visualizing instance importance scores.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orig_data</code></strong> :&ensp;<code>torch.Tensor</code> or <code>numpy.Array</code>, default <code>None</code></dt>
<dd>Original data used in the machine learning model. Used here to fetch
the true ID corresponding to the plotted sequence.</dd>
<dt><strong><code>inst_scores</code></strong> :&ensp;<code>numpy.Array</code>, default <code>None</code></dt>
<dd>Array containing the instance importance scores to be plotted.</dd>
<dt><strong><code>seq_id</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>ID or sequence index that select which time series / sequences to
use in the plot. If it's a single value, the method plots a single
sequence.</dd>
<dt><strong><code>pred_prob</code></strong> :&ensp;<code>numpy.Array</code> or <code>torch.Tensor</code> or <code>list</code> of <code>floats</code>, default <code>None</code></dt>
<dd>Array containing the prediction probabilities for each sequence in
the input data (orig_data). Only relevant if show_pred_prob is True.</dd>
<dt><strong><code>uniform_spacing</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Defines whether or not the sequences are displayed with uniform
spacing (i.e. fixed distance) between their samples.</dd>
<dt><strong><code>show_pred_prob</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a percentage bar chart will be shown to the right of
the standard instance importance plot. If <code>pred_prob</code> isn't
specified but the labels are, the prediction probabilities will be
automatically calculated.</dd>
<dt><strong><code>show_title</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the plot will have a title displayed above.</dd>
<dt><strong><code>show_colorbar</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a bar legend will be shown, corresponding each color
to each respective value.</dd>
<dt><strong><code>click_mode</code></strong> :&ensp;<code>string</code>, default <code>'event+select'</code></dt>
<dd>Determines the mode of single click interactions. "event" is the
default value and emits the <code>plotly_click</code> event. In addition this
mode emits the <code>plotly_selected</code> event in drag modes "lasso" and
"select", but with no event data attached (kept for compatibility
reasons). The "select" flag enables selecting single data points via
click. This mode also supports persistent selections, meaning that
pressing Shift while clicking, adds to / subtracts from an existing
selection. "select" with <code>hovermode</code>: "x" can be confusing, consider
explicitly setting <code>hovermode</code>: "closest" when using this feature.
Selection events are sent accordingly as long as "event" flag is set
as well. When the "event" flag is missing, <code>plotly_click</code> and
<code>plotly_selected</code> events are not fired.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Labels corresponding to the data used, either specified in the input
or all the data that the interpreter has.</dd>
<dt><strong><code>seq_len</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Sequence lengths which represent the true, unpadded size of the
input sequences.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>0</code></dt>
<dd>Value to use as a threshold in the plot's color selection. In other
words, values that exceed this threshold will have one color while the
remaining have a different one, as specified in the parameters.</dd>
<dt><strong><code>get_fig_obj</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the function returns the object that contains the
displayed plotly figure.</dd>
<dt><strong><code>tensor_idx</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the ID specified in the respective parameter
constitutes the index where the desired sequence resides. Otherwise,
it's the actual unique identifier that appears in the original data.</dd>
<dt><strong><code>max_seq</code></strong> :&ensp;<code>int</code>, default <code>10</code></dt>
<dd>Maximum number of sequences to show in the plot. This is meant to
prevent cramming too many sequences into the graph window.</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code>, default <code>'white'</code></dt>
<dd>The plot's background color. Can be set in color name (e.g. 'white'),
hexadecimal code (e.g. '#555') or RGB (e.g. 'rgb(0,0,255)').</dd>
<dt><strong><code>font_family</code></strong> :&ensp;<code>str</code>, default <code>'Roboto'</code></dt>
<dd>Text font family to be used in the numbers shown next to the graph.</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code>, default <code>14</code></dt>
<dd>Text font size to be used in the numbers shown next to the graph.</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code>, default <code>'black'</code></dt>
<dd>Text font color to be used in the numbers shown next to the graph. Can
be set in color name (e.g. 'white'), hexadecimal code (e.g. '#555') or
GB (e.g. 'rgb(0,0,255)').</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objs.Figure</code> or <code>None</code></dt>
<dd>If argument get_fig_obj is set to True, the figure object is returned.
Otherwise, nothing is returned, only the plot is showned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instance_importance_plot(self, orig_data=None, inst_scores=None, seq_id=None,
                             pred_prob=None, uniform_spacing=False,
                             show_pred_prob=True, show_title=True,
                             show_colorbar=True, click_mode=&#39;event+select&#39;,
                             labels=None, seq_len=None, threshold=0,
                             get_fig_obj=False, tensor_idx=True,
                             max_seq=10, background_color=&#39;white&#39;,
                             font_family=&#39;Roboto&#39;, font_size=14,
                             font_color=&#39;black&#39;):
    &#39;&#39;&#39;Create a bar chart that allows visualizing instance importance scores.

    Parameters
    ----------
    orig_data : torch.Tensor or numpy.Array, default None
        Original data used in the machine learning model. Used here to fetch
        the true ID corresponding to the plotted sequence.
    inst_scores : numpy.Array, default None
        Array containing the instance importance scores to be plotted.
    seq_id : int, default None
        ID or sequence index that select which time series / sequences to
        use in the plot. If it&#39;s a single value, the method plots a single
        sequence.
    pred_prob : numpy.Array or torch.Tensor or list of floats, default None
        Array containing the prediction probabilities for each sequence in
        the input data (orig_data). Only relevant if show_pred_prob is True.
    uniform_spacing : bool, default False
        Defines whether or not the sequences are displayed with uniform
        spacing (i.e. fixed distance) between their samples.
    show_pred_prob : bool, default True
        If set to True, a percentage bar chart will be shown to the right of
        the standard instance importance plot. If `pred_prob` isn&#39;t
        specified but the labels are, the prediction probabilities will be
        automatically calculated.
    show_title : bool, default True
        If set to True, the plot will have a title displayed above.
    show_colorbar : bool, default True
        If set to True, a bar legend will be shown, corresponding each color
        to each respective value.
    click_mode : string, default &#39;event+select&#39;
        Determines the mode of single click interactions. &#34;event&#34; is the
        default value and emits the `plotly_click` event. In addition this
        mode emits the `plotly_selected` event in drag modes &#34;lasso&#34; and
        &#34;select&#34;, but with no event data attached (kept for compatibility
        reasons). The &#34;select&#34; flag enables selecting single data points via
        click. This mode also supports persistent selections, meaning that
        pressing Shift while clicking, adds to / subtracts from an existing
        selection. &#34;select&#34; with `hovermode`: &#34;x&#34; can be confusing, consider
        explicitly setting `hovermode`: &#34;closest&#34; when using this feature.
        Selection events are sent accordingly as long as &#34;event&#34; flag is set
        as well. When the &#34;event&#34; flag is missing, `plotly_click` and
        `plotly_selected` events are not fired.
    labels : torch.Tensor, default None
        Labels corresponding to the data used, either specified in the input
        or all the data that the interpreter has.
    seq_len : int, default None
        Sequence lengths which represent the true, unpadded size of the
        input sequences.
    threshold : int or float, default 0
        Value to use as a threshold in the plot&#39;s color selection. In other
        words, values that exceed this threshold will have one color while the
        remaining have a different one, as specified in the parameters.
    get_fig_obj : bool, default False
        If set to True, the function returns the object that contains the
        displayed plotly figure.
    tensor_idx : bool, default True
        If set to True, the ID specified in the respective parameter
        constitutes the index where the desired sequence resides. Otherwise,
        it&#39;s the actual unique identifier that appears in the original data.
    max_seq : int, default 10
        Maximum number of sequences to show in the plot. This is meant to
        prevent cramming too many sequences into the graph window.
    background_color : str, default &#39;white&#39;
        The plot&#39;s background color. Can be set in color name (e.g. &#39;white&#39;),
        hexadecimal code (e.g. &#39;#555&#39;) or RGB (e.g. &#39;rgb(0,0,255)&#39;).
    font_family : str, default &#39;Roboto&#39;
        Text font family to be used in the numbers shown next to the graph.
    font_size : int, default 14
        Text font size to be used in the numbers shown next to the graph.
    font_color : str, default &#39;black&#39;
        Text font color to be used in the numbers shown next to the graph. Can
        be set in color name (e.g. &#39;white&#39;), hexadecimal code (e.g. &#39;#555&#39;) or
        GB (e.g. &#39;rgb(0,0,255)&#39;).

    Returns
    -------
    fig : plotly.graph_objs.Figure or None
        If argument get_fig_obj is set to True, the figure object is returned.
        Otherwise, nothing is returned, only the plot is showned.&#39;&#39;&#39;
    if orig_data is None:
        # Use all the data if none was specified
        orig_data = self.data

        if labels is None:
            labels = self.labels

    if inst_scores is None:
        if self.inst_scores is None:
            raise Exception(&#39;ERROR: No instance importance scores found. If the scores aren\&#39;t specified, then they must have already been calculated through the interpret_model method.&#39;)
        # Use all the previously calculated scores if none were specified
        inst_scores = self.inst_scores

    # Plot the instance importance of multiple sequences
    # Convert the instance scores data into a NumPy array
    if type(inst_scores) is torch.Tensor:
        inst_scores = inst_scores.detach().numpy()
    elif type(inst_scores) is list:
        inst_scores = np.array(inst_scores)

    # if is not tensor_idx:
    # [TODO] Search for the index associated to the specific ID asked for by the user
    # [TODO] Allow to search for multiple indeces and generate a multiple patients time series plot from it

    if len(inst_scores.shape) == 1 or (seq_id is not None and type(seq_id) is not list):
        # True sequence length of the current id&#39;s data
        if seq_len is None:
            seq_len = self.seq_len_dict[orig_data[seq_id, 0, self.id_column_num].item()]

        # [TODO] Add a prediction probability bar plot like in the multiple sequences case

        # Plot the instance importance of one sequence
        plot_data = [go.Bar(
                        x = list(range(seq_len)),
                        y = inst_scores[seq_id, :seq_len],
                        marker=dict(color=du.utils.set_bar_color(inst_scores, seq_id, seq_len,
                                                                 threshold=threshold,
                                                                 pos_color=POS_COLOR,
                                                                 neg_color=NEG_COLOR))
                      )]
        layout = go.Layout(
                            title=f&#39;Instance importance scores for ID {int(orig_data[id, 0, self.id_column_num])}&#39;,
                            xaxis=dict(title=&#39;Instance&#39;),
                            yaxis=dict(title=&#39;Importance scores&#39;)
                          )
    else:
        if seq_id is None:
            # Use all the sequences data if a subset isn&#39;t specified
            seq_id = list(range(inst_scores.shape[0]))
        # Select the desired data according to the specified IDs
        inst_scores = inst_scores[seq_id, :]
        orig_data = orig_data[seq_id, :, :]
        # Unique patient IDs in string format
        patients = [str(int(item)) for item in [tensor.item()
                    for tensor in list(orig_data[:, 0, self.id_column_num])]]
        if uniform_spacing is True:
            # Sequence instances count, used as X in the plot
            seq_insts_x = [list(range(inst_scores.shape[1]))
                           for patient in range(len(patients))]
        else:
            # Use the original timestamp values as the X axis
            seq_insts_x = [int(tensor) for seq_list
                           in [list(ts_array) for ts_array in list(orig_data[:, :, self.inst_column_num])]
                           for tensor in seq_list]
        # Patients ids repeated max sequence length times, used as Y in the plot
        patients_y = [[patient]*inst_scores.shape[1] for patient in list(patients)]
        # Flatten seq_insts and patients_y
        seq_insts_x = list(np.array(seq_insts_x).flatten())
        patients_y = list(np.array(patients_y).flatten())
        # Define colors for the data points based on their normalized scores (from 0 to 1 instead of -1 to 1)
        colors = [val for val in inst_scores.flatten()]
        # Count the number of already deleted paddings
        count = 0

        for i in range(inst_scores.shape[0]):
            for j in range(inst_scores.shape[1]):
                if inst_scores[i, j] == self.padding_value:
                    # Delete elements that represent paddings, not real instances
                    del seq_insts_x[i*inst_scores.shape[1]+j-count]
                    del patients_y[i*inst_scores.shape[1]+j-count]
                    del colors[i*inst_scores.shape[1]+j-count]
                    # Increment the counting of already deleted items
                    count += 1

        if show_pred_prob is True:
            if pred_prob is None:
                if labels is None:
                    raise Exception(&#39;ERROR: By setting `show_pred_prob` to True, either the prediction probabilities (pred_prob) or the labels must be provided.&#39;)
                # Calculate the prediction probabilities for the provided data
                pred_prob, _ = du.deep_learning.model_inference(self.model, data=(orig_data, labels),
                                                                metrics=[&#39;&#39;], model_type=self.model_type,
                                                                is_custom=self.is_custom,
                                                                seq_len_dict=self.seq_len_dict,
                                                                padding_value=self.padding_value,
                                                                output_rounded=False,
                                                                seq_final_outputs=True,
                                                                cols_to_remove=[self.id_column_num, self.inst_column_num],
                                                                already_embedded=self.already_embedded)
            # Convert the prediction probability data into a NumPy array
            if type(pred_prob) is torch.Tensor:
                pred_prob = pred_prob.detach().numpy()
            elif type(pred_prob) is list:
                pred_prob = np.array(pred_prob)
            # Select the desired data according to the specified IDs
            pred_prob = pred_prob[seq_id]
            # Colors to use in the prediction probability bar plots
            pred_colors = cl.scales[&#39;8&#39;][&#39;div&#39;][&#39;RdYlGn&#39;]
            # Create &#34;percentage bar&#34; plots through pairs of unfilled and filled rectangles
            shapes_list = []
            # Starting y coordinate of the first shape
            y0 = -0.25
            # Height of the shapes (y length)
            step = 0.5
            # Maximum width of the shapes
            max_width = 1
            for i in range(len(patients)):
                # Set the starting x coordinate to after the last data point
                x0 = inst_scores.shape[1]
                # Set the filling length of the shape
                x1_fill = x0 + pred_prob[i] * max_width
                shape_unfilled = {
                                    &#39;type&#39;: &#39;rect&#39;,
                                    &#39;x0&#39;: x0,
                                    &#39;y0&#39;: y0,
                                    &#39;x1&#39;: x0 + max_width,
                                    &#39;y1&#39;: y0 + step,
                                    &#39;line&#39;: {
                                                &#39;color&#39;: &#39;rgba(0, 0, 0, 1)&#39;,
                                                &#39;width&#39;: 2,
                                            },
                                }
                shape_filled = {
                                    &#39;type&#39;: &#39;rect&#39;,
                                    &#39;x0&#39;: x0,
                                    &#39;y0&#39;: y0,
                                    &#39;x1&#39;: x1_fill,
                                    &#39;y1&#39;: y0 + step,
                                    &#39;fillcolor&#39;: pred_colors[int(len(pred_colors)-1-max(pred_prob[i]*len(pred_colors)-1, 0))]
                                }
                shapes_list.append(shape_unfilled)
                shapes_list.append(shape_filled)
                # Set the starting y coordinate for the next shapes
                y0 = y0 + 2 * step

            # Getting points along the percentage bar plots
            x_range = [list(np.array(range(0, 10, 1))*0.1+inst_scores.shape[1]) for idx in range(len(patients))]
            # Flatten the list
            text_x = [item for sublist in x_range for item in sublist]
            # Y coordinates of the prediction probability text
            text_y = [patient for patient in patients for idx in range(10)]
            # Prediction probabilities in text form, to appear in the plot
            text_content = [pred_prob[idx] for idx in range(len(pred_prob)) for i in range(10)]
            # [TODO] Ajdust the zoom so that the initial plot doens&#39;t block part of the first and last sequences that show up

        # Create plotly chart
        plot_data = [dict(
            x=seq_insts_x,
            y=patients_y,
            marker=dict(
                color=colors,
                size=12,
                line = dict(
                    color = &#39;black&#39;,
                    width = 1
                ),
                colorscale=[[0, &#39;rgba(30,136,229,1)&#39;], [0.5, &#39;white&#39;], [1, &#39;rgba(255,13,87,1)&#39;]],
                cmax=1,
                cmin=-1,
            ),
            mode=&#39;markers&#39;,
            type=&#39;scatter&#39;,
            hoverinfo=&#39;x+y&#39;
        )]
        layout = dict(
            paper_bgcolor=background_color,
            plot_bgcolor=background_color,
            font=dict(
                family=font_family,
                size=font_size,
                color=font_color
            ),
            xaxis=dict(
                title=&#39;Instance&#39;,
                showgrid=False,
                zeroline=False
            ),
            yaxis=dict(
                title=&#39;Patient ID&#39;,
                showgrid=False,
                zeroline=False,
                type=&#39;category&#39;
            ),
            hovermode=&#39;closest&#39;,
            showlegend=False,
            clickmode=click_mode
        )
        if show_title is True:
            layout[&#39;title&#39;] = &#39;Instance importance&#39;
            layout[&#39;margin&#39;] = dict(l=0, r=0, t=30, b=0, pad=0)
        else:
            layout[&#39;margin&#39;] = dict(l=0, r=0, t=0, b=0, pad=0)
        if show_colorbar is True:
            layout[&#39;meta&#39;] = dict()
            layout[&#39;meta&#39;][&#39;colorbar&#39;] = dict(title=&#39;Scores&#39;)
        if show_pred_prob is True:
            # Add hover text to indicate the final output probabilities
            prob_hover_info = go.Scatter(
                x=text_x,
                y=text_y,
                text=text_content,
                mode=&#39;text&#39;,
                textfont=dict(size = 1, color=&#39;#ffffff&#39;),
                hoverinfo=&#39;y+text&#39;
            )
            plot_data.append(prob_hover_info)
            # Add final output probabilities bar plots
            layout[&#39;shapes&#39;] = shapes_list
        if len(patients) &gt; max_seq:
            # Prevent cramming too many sequences into the plot
            layout[&#39;yaxis&#39;][&#39;range&#39;] = [patients[max_seq], patients[0]]
    # Show the plot
    fig = go.Figure(plot_data, layout)

    if get_fig_obj:
        # Only return the figure object if specified by the user
        return fig
    else:
        py.iplot(fig)
        return</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.interpret_model"><code class="name flex">
<span>def <span class="ident">interpret_model</span></span>(<span>self, bkgnd_data=None, test_data=None, test_labels=None, new_data=False, model_type=None, df=None, instance_importance=True, feature_importance=False, fast_calc=None, create_new_explainer=True, see_progress=True, save_data=True, debug_loss=False, total_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to calculate scores of feature and/or instance importance, in
order to be able to interpret a model on a given data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bkgnd_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>In case of setting fast_calc to False, which makes the algorithm
require background data in SHAP during the feature importance, the
background data used in the explainer can be set through this
parameter.</dd>
<dt><strong><code>test_data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Optionally, the user can specify a subset of data on which model
interpretation will be made (i.e. calculating feature and/or
instance importance) as a PyTorch tensor. Otherwise, all the data is
used.</dd>
<dt><strong><code>test_labels</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Labels corresponding to the data used, either specified in the input
or all the data that the interpreter has.</dd>
<dt><strong><code>new_data</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, it indicates that the data that will be interpreted
hasn't been seen before, i.e. it has different ids than those in the
original dataset defined in the object initialization. This implies
that a dataframe of the new data is provided (parameter df) so that
the sequence lengths are calculated. Otherwise, the original
sequence lengths known by the model interpreter are used.</dd>
<dt><strong><code>model_type</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Sets the type of machine learning model. Important to know what type
of inference and data processing to do. Currently available options
are ['multivariate_rnn', 'mlp'].</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code>, default <code>None</code></dt>
<dd>Dataframe containing the new data so as to calculate the sequence
lengths of the new ids. Only used if new_data is set to True and
<code>model_type</code> is 'multivariate_rnn'.</dd>
<dt><strong><code>instance_importance</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, instance importance is made on the data. In other
words, the algorithm will analyze the impact that each instance of
an input sequence had on the output.</dd>
<dt><strong><code>feature_importance</code></strong> :&ensp;<code>bool</code> or <code>string</code>, default <code>False</code></dt>
<dd>Defines which feature importance interpretability technique to use.
The algorithm will analyze the impact that each feature of
an instance had on the output. This is analyzed instance by instance,
not in the entire sequence at once. For example, from the feature
importance alone, it's not straightforward how a value in a previous
instance impacted the current output. Current options include SHAP
Kernel Explainer ('shap') and 'mask filter'. If set to False, no
feature importance will be done.</dd>
<dt><strong><code>fast_calc</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>If set to True, the algorithm uses less background samples (SHAP)
or optimization steps (mask filter), in order to do a fast
interpretation of the model. If set to False, the process takes
more time in order to get a more precise and truthful
interpretation of the model's behavior, requiring longer
computation times.</dd>
<dt><strong><code>create_new_explainer</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Sets if we'll create a new SHAP KernelExplainer or if we'll use a
previously defined one in the current model interpreter object.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the instance importance scores calculations.</dd>
<dt><strong><code>save_data</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the possible background data (used in the SHAP
explainer) and the test data (on which importance scores are
calculated) are saved as object attributes.</dd>
<dt><strong><code>debug_loss</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Debugging flag, which makes the method also return an array of the
mask filter optimization loss.</dd>
<dt><strong><code>total_length</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>If not None, the feature importance scores will be padded to have
length total_length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inst_scores</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Array containing the importance scores of each instance in the
given input sequences. Only calculated if instance_importance is set
to True.</dd>
<dt><strong><code>feat_scores</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Array containing the importance scores of each feature, of each
instance, in the given input sequences. Only calculated if
feature_importance is set to True.</dd>
<dt><code>if debug_loss is True:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>loss_mtx</code></strong> :&ensp;<code>np.Array</code></dt>
<dd>Matrix containing the loss values of the mask filter optimization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_model(self, bkgnd_data=None, test_data=None, test_labels=None,
                    new_data=False, model_type=None, df=None,
                    instance_importance=True, feature_importance=False,
                    fast_calc=None, create_new_explainer=True,
                    see_progress=True, save_data=True, debug_loss=False,
                    total_length=None):
    &#39;&#39;&#39;Method to calculate scores of feature and/or instance importance, in
    order to be able to interpret a model on a given data.

    Parameters
    ----------
    bkgnd_data : torch.Tensor, default None
        In case of setting fast_calc to False, which makes the algorithm
        require background data in SHAP during the feature importance, the
        background data used in the explainer can be set through this
        parameter.
    test_data : torch.Tensor, default None
        Optionally, the user can specify a subset of data on which model
        interpretation will be made (i.e. calculating feature and/or
        instance importance) as a PyTorch tensor. Otherwise, all the data is
        used.
    test_labels : torch.Tensor, default None
        Labels corresponding to the data used, either specified in the input
        or all the data that the interpreter has.
    new_data : bool, default False
        If set to True, it indicates that the data that will be interpreted
        hasn&#39;t been seen before, i.e. it has different ids than those in the
        original dataset defined in the object initialization. This implies
        that a dataframe of the new data is provided (parameter df) so that
        the sequence lengths are calculated. Otherwise, the original
        sequence lengths known by the model interpreter are used.
    model_type : string, default None
        Sets the type of machine learning model. Important to know what type
        of inference and data processing to do. Currently available options
        are [&#39;multivariate_rnn&#39;, &#39;mlp&#39;].
    df : pandas.DataFrame, default None
        Dataframe containing the new data so as to calculate the sequence
        lengths of the new ids. Only used if new_data is set to True and
        `model_type` is &#39;multivariate_rnn&#39;.
    instance_importance : bool, default True
        If set to True, instance importance is made on the data. In other
        words, the algorithm will analyze the impact that each instance of
        an input sequence had on the output.
    feature_importance : bool or string, default False
        Defines which feature importance interpretability technique to use.
        The algorithm will analyze the impact that each feature of
        an instance had on the output. This is analyzed instance by instance,
        not in the entire sequence at once. For example, from the feature
        importance alone, it&#39;s not straightforward how a value in a previous
        instance impacted the current output. Current options include SHAP
        Kernel Explainer (&#39;shap&#39;) and &#39;mask filter&#39;. If set to False, no
        feature importance will be done.
    fast_calc : bool, default None
        If set to True, the algorithm uses less background samples (SHAP)
        or optimization steps (mask filter), in order to do a fast
        interpretation of the model. If set to False, the process takes
        more time in order to get a more precise and truthful
        interpretation of the model&#39;s behavior, requiring longer
        computation times.
    create_new_explainer : bool, default True
        Sets if we&#39;ll create a new SHAP KernelExplainer or if we&#39;ll use a
        previously defined one in the current model interpreter object.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the instance importance scores calculations.
    save_data : bool, default True
        If set to True, the possible background data (used in the SHAP
        explainer) and the test data (on which importance scores are
        calculated) are saved as object attributes.
    debug_loss : bool, default False
        Debugging flag, which makes the method also return an array of the
        mask filter optimization loss.
    total_length : int, default None
        If not None, the feature importance scores will be padded to have
        length total_length.

    Returns
    -------
    inst_scores : numpy.Array
        Array containing the importance scores of each instance in the
        given input sequences. Only calculated if instance_importance is set
        to True.
    feat_scores : numpy.Array
        Array containing the importance scores of each feature, of each
        instance, in the given input sequences. Only calculated if
        feature_importance is set to True.

    if debug_loss is True:

    loss_mtx : np.Array
        Matrix containing the loss values of the mask filter optimization.
    &#39;&#39;&#39;
    # Confirm that the model is in evaluation mode to deactivate dropout
    self.model.eval()

    if feature_importance is not None and feature_importance is not False:
        try:
            feature_importance = feature_importance.lower()
            if feature_importance != &#39;shap&#39; and feature_importance != &#39;mask filter&#39;:
                raise Exception(f&#39;ERROR: Specified {feature_importance} feature importance method isn\&#39;t valid. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)
        except:
            raise Exception(f&#39;ERROR: {feature_importance} is an incorrectly defined feature importance method, as it should be a string. Available options are \&#34;shap\&#34; and\&#34;mask filter\&#34;.&#39;)

    if fast_calc is None:
        # Use the predefined option if fast_calc isn&#39;t set in the function call
        fast_calc = self.fast_calc
    else:
        self.fast_calc = fast_calc
    if model_type is None:
        # Use the predefined option if model_type isn&#39;t set in the function call
        model_type = self.model_type
    else:
        self.model_type = model_type
    if total_length is None:
        # Use the predefined option if total_length isn&#39;t set in the function call
        total_length = self.total_length

    if test_labels is not None:
        if type(test_labels) is np.ndarray:
            # Convert from numpy to pytorch
            test_labels = torch.from_numpy(test_labels)

    if test_data is None:
        if fast_calc:
            # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
            test_data = self.data
            test_labels = self.labels
        else:
            if bkgnd_data is None:
                # Get the background and test sets from the dataset
                bkgnd_data, test_data = self.create_bkgnd_test_sets()
            else:
                # Get the test set from the dataset
                _, test_data = self.create_bkgnd_test_sets()
    elif type(test_data) is np.ndarray:
        # Convert from numpy to pytorch
        test_data = torch.from_numpy(test_data)

    if model_type == &#39;multivariate_rnn&#39;:
        if new_data is True:
            if df is None:
                raise Exception(&#39;ERROR: A dataframe must be provided in order to work with the new data.&#39;)
            # Find the sequence lengths of the new data
            seq_len_dict = du.padding.get_sequence_length_dict(df, id_column=self.id_column_num, ts_column=self.inst_column_num)
            # Sort the data by sequence length
            test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, seq_len_dict, test_labels)
        else:
            # Sort the data by sequence length
            test_data, test_labels, x_lengths_test = du.padding.sort_by_seq_len(test_data, self.seq_len_dict, test_labels)

    if not fast_calc:
        if bkgnd_data is None:
            # Get the background set from the dataset
            bkgnd_data, _ = self.create_bkgnd_test_sets()
        elif type(bkgnd_data) is np.ndarray:
            # Convert from numpy to pytorch
            bkgnd_data = torch.from_numpy(bkgnd_data)

    if save_data:
        # Save the data used in the model interpretation
        self.bkgnd_data = bkgnd_data
        self.test_data = test_data
        self.test_labels = test_labels

    if instance_importance is True:
        print(&#39;Calculating instance importance scores...&#39;)
        # Calculate the scores of importance of each instance
        self.inst_scores = self.instance_importance(test_data, test_labels, x_lengths_test, see_progress)

    if feature_importance is not False:
        print(&#39;Calculating feature importance scores...&#39;)
        # Calculate the scores of importance of each feature in each instance
        if feature_importance == &#39;mask filter&#39; and debug_loss:
            self.feat_scores, loss_mtx = self.feature_importance(test_data, model_type,
                                                                 feature_importance,
                                                                 fast_calc, see_progress,
                                                                 bkgnd_data, debug_loss=True,
                                                                 total_length=total_length)
        else:
            self.feat_scores = self.feature_importance(test_data, model_type, feature_importance,
                                                       fast_calc, see_progress, bkgnd_data,
                                                       create_new_explainer=create_new_explainer,
                                                       debug_loss=False, total_length=total_length)

    print(&#39;Done!&#39;)

    if instance_importance and feature_importance:
        if fast_calc and debug_loss:
            return self.inst_scores, self.feat_scores, loss_mtx
        else:
            return self.inst_scores, self.feat_scores
    elif instance_importance and not feature_importance:
        return self.inst_scores
    elif not instance_importance and feature_importance:
        if fast_calc and debug_loss:
            return self.feat_scores, loss_mtx
        else:
            return self.feat_scores
    else:
        warnings.warn(&#39;Without setting instance_importance nor feature_importance to True, the interpret_model function won\&#39;t do anything relevant.&#39;)
        return</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.mask_filter"><code class="name flex">
<span>def <span class="ident">mask_filter</span></span>(<span>self, data=None, x_lengths=None, max_iter=100, l1_coeff=1, lr=0.001, recur_layer=None, see_progress=True, debug_loss=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a mask filter for the given data samples, through an
appropriate optimization.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>Data sample(s) which will be used to determine the most relevant
features. In case of multivariate sequential data, each instance will
be analyzed seperately. If None, all data known to the model
interpreter will be used.</dd>
<dt><strong><code>x_lengths</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Sorted list of sequence lengths, relative to the input data.</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code>, default <code>100</code></dt>
<dd>Maximum number of iterations of the mask filter optimization, for
each instance.</dd>
<dt><strong><code>l1_coeff</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Weight given in the loss function to the L1 norm of the mask filter.</dd>
<dt><strong><code>lr</code></strong> :&ensp;<code>float</code>, default <code>0.001</code></dt>
<dd>Learning rate used in the optimization algorithm.</dd>
<dt><strong><code>recur_layer</code></strong> :&ensp;<code>torch.nn.LSTM</code> or <code>torch.nn.GRU</code> or <code>torch.nn.RNN</code>, default <code>None</code></dt>
<dd>Pointer to the recurrent layer in the model, if it exists. It should
either be a LSTM, GRU or RNN network. If none is specified, the
method will automatically search for a recurrent layer in the model.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the feature importance scores calculations.</dd>
<dt><strong><code>debug_loss</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Debugging flag, which makes the method also return an array of the
optimization loss.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Output mask, after finishing the optimization for every specified
sample. It will be inverted before returning, so as to be an array
filled with zeros, except in the indeces corresponding to the most
relevant features, where it will be one.</dd>
<dt><code>if debug_loss is True:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>loss_mtx</code></strong> :&ensp;<code>np.Array</code></dt>
<dd>Matrix containing the loss values of the mask filter optimization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_filter(self, data=None, x_lengths=None, max_iter=100, l1_coeff=1,
                lr=0.001, recur_layer=None, see_progress=True, debug_loss=False):
    &#39;&#39;&#39;Calculate a mask filter for the given data samples, through an
    appropriate optimization.

    Parameters
    ----------
    data : torch.Tensor, default None
        Data sample(s) which will be used to determine the most relevant
        features. In case of multivariate sequential data, each instance will
        be analyzed seperately. If None, all data known to the model
        interpreter will be used.
    x_lengths : list of int
        Sorted list of sequence lengths, relative to the input data.
    max_iter : int, default 100
        Maximum number of iterations of the mask filter optimization, for
        each instance.
    l1_coeff : int, default 1
        Weight given in the loss function to the L1 norm of the mask filter.
    lr : float, default 0.001
        Learning rate used in the optimization algorithm.
    recur_layer : torch.nn.LSTM or torch.nn.GRU or torch.nn.RNN, default None
        Pointer to the recurrent layer in the model, if it exists. It should
        either be a LSTM, GRU or RNN network. If none is specified, the
        method will automatically search for a recurrent layer in the model.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the feature importance scores calculations.
    debug_loss : bool, default False
        Debugging flag, which makes the method also return an array of the
        optimization loss.

    Returns
    -------
    mask : numpy.Array
        Output mask, after finishing the optimization for every specified
        sample. It will be inverted before returning, so as to be an array
        filled with zeros, except in the indeces corresponding to the most
        relevant features, where it will be one.

    if debug_loss is True:

    loss_mtx : np.Array
        Matrix containing the loss values of the mask filter optimization.
    &#39;&#39;&#39;
    # [TODO] Work on an option to use input data different from multivariate sequential
    if data is None:
        # If a subset of data to interpret isn&#39;t specified, the interpreter will use all the data
        data = self.data
    if x_lengths is None:
        # Sort the data by sequence length
        data, x_lengths = du.padding.sort_by_seq_len(data, self.seq_len_dict)
    if len(data.shape) &gt; 1 and recur_layer is None:
        # Search for a recurrent layer
        if hasattr(self.model, &#39;lstm&#39;):
            recur_layer = self.model.lstm
        elif hasattr(self.model, &#39;gru&#39;):
            recur_layer = self.model.gru
        elif hasattr(self.model, &#39;rnn&#39;):
            recur_layer = self.model.rnn
        else:
            raise Exception(&#39;ERROR: No recurrent layer found. Please specify it in the recur_layer argument.&#39;)

    # Confirm that the model is in evaluation mode to deactivate dropout
    self.model.eval()
    # Create a mask filter variable, initialized as an all ones tensor
    mask = torch.ones(data.shape)
    # [DEBUG] Create a loss matrix to analyse the convergence of mask filter optimizations
    loss_mtx = []

    if len(data.shape) == 3:
        # Loop to go through each sequence in the input data
        for seq in tqdm(range(data.shape[0]), disable=not see_progress):
            # Get the true length of the current sequence
            seq_len = x_lengths[seq]
            # Loop to go through each instance in the input sequence
            for inst in tqdm(range(seq_len), disable=not see_progress):
                hidden_state = None
                # Get the hidden state that the model receives as an input
                if inst &gt; 0:
                    # Get the hidden state outputed from the previous recurrent cell
                    _, hidden_state = recur_layer(data[:inst])
                    # Avoid backpropagating through previous instances
                    if type(hidden_state) is tuple:
                        hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                    else:
                        hidden_state.detach_()
                # Temporary mask filter for he current instance
                tmp_mask = Variable(mask[seq, inst, :], requires_grad=True)
                # [DEBUG] List of the current optimization&#39;s losses
                tmp_loss_list = []
                # Mask filter optimization loop
                for iter in tqdm(range(max_iter), disable=not see_progress):
                    # Calculate the model&#39;s output to the original, unchanged instance data
                    ref_output = self.model(data[seq, inst, :].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                    # Prevent mask filter optimization from backpropagating through the reference output
                    ref_output.detach_()
                    # Perform a single optimization step
                    tmp_mask, tmp_loss = self.mask_filter_step(tmp_mask, data[seq, inst, :], ref_output, l1_coeff, hidden_state, debug_loss=debug_loss)
                    tmp_loss_list.append(tmp_loss)
                # Save the optimized mask filter of the current instance
                mask[seq, inst, :] = tmp_mask
                # [DEBUG] Add the current instance&#39;s optimization logs to the overall loss matrix
                loss_mtx.append(tmp_loss_list)

    elif len(data.shape) == 2:
        # Loop to go through each instance in the input sequence
        for inst in tqdm(range(data.shape[0]), disable=not see_progress):
            hidden_state = None
            # Get the hidden state that the model receives as an input
            if inst &gt; 0:
                # Get the hidden state outputed from the previous recurrent cell
                _, hidden_state = recur_layer(data[:inst])
                # Avoid backpropagating through previous instances
                if type(hidden_state) is tuple:
                    hidden_state = (hidden_state[0].detach(), hidden_state[1].detach())
                else:
                    hidden_state.detach_()
            # Temporary mask filter for he current instance
            tmp_mask = Variable(mask[inst], requires_grad=True)
            # Mask filter optimization loop
            for iter in tqdm(range(max_iter), disable=not see_progress):
                # Calculate the model&#39;s output to the original, unchanged instance data
                ref_output = self.model(data[inst].unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
                # Prevent mask filter optimization from backpropagating through the reference output
                ref_output.detach_()
                # Perform a single optimization step
                tmp_mask = self.mask_filter_step(tmp_mask, data[inst], ref_output, l1_coeff, hidden_state)
            # Save the optimized mask filter of the current instance
            mask[inst] = tmp_mask

    elif len(data.shape) == 1:
        # Make sure that the mask can be optimized properly
        mask.requires_grad_()
        # Mask filter optimization loop
        for iter in tqdm(range(max_iter), disable=not see_progress):
            # Calculate the model&#39;s output to the original, unchanged instance data
            ref_output = self.model(data.unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
            # Prevent mask filter optimization from backpropagating through the reference output
            ref_output.detach_()
            # Perform a single optimization step
            mask = self.mask_filter_step(mask, data, ref_output, l1_coeff)

    else:
        raise Exception(f&#39;ERROR: Can\&#39;t handle data with more than 3 dimensions. Submitted data with {len(data.shape)} dimensions.&#39;)

    # Return the inverted version of the mask, to atrribute 1 (one) to the most relevant features
    if debug_loss:
        return 1 - mask, loss_mtx
    else:
        return 1 - mask</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.mask_filter_step"><code class="name flex">
<span>def <span class="ident">mask_filter_step</span></span>(<span>self, mask, data, ref_output, l1_coeff=1, hidden_state=None, debug_loss=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a single optimization step to calculate a new version of the
mask filter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Current mask filter, either the initial one or from the previous
optimization iteration.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Data sample which will be used to determine the most relevant
features. In case of multivariate sequential data, this must be a
single instance of a sequence.</dd>
<dt><strong><code>ref_output</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>Model's output to the original instance, with no mask filters applied.</dd>
<dt><strong><code>l1_coeff</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Weight given in the loss function to the L1 norm of the mask filter.</dd>
<dt><strong><code>hidden_state</code></strong> :&ensp;<code>torch.Tensor</code> or <code>tuple</code> of <code>two torch.Tensor</code>, default <code>None</code></dt>
<dd>Hidden state coming from the previous recurrent cell. If none is
specified, the hidden state is initialized as zero.</dd>
<dt><strong><code>debug_loss</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Debugging flag, which makes the method also return an array of the
optimization loss.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>numpy.Array</code></dt>
<dd>Current mask filter, after the performed optimization step.</dd>
<dt><code>if debug_loss is True:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>loss</code></strong> :&ensp;<code>float</code></dt>
<dd>Current loss value of the mask filter optimization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_filter_step(self, mask, data, ref_output, l1_coeff=1,
                     hidden_state=None, debug_loss=False):
    &#39;&#39;&#39;Perform a single optimization step to calculate a new version of the
    mask filter.

    Parameters
    ----------
    mask : numpy.Array
        Current mask filter, either the initial one or from the previous
        optimization iteration.
    data : torch.Tensor
        Data sample which will be used to determine the most relevant
        features. In case of multivariate sequential data, this must be a
        single instance of a sequence.
    ref_output : torch.Tensor or float
        Model&#39;s output to the original instance, with no mask filters applied.
    l1_coeff : int, default 1
        Weight given in the loss function to the L1 norm of the mask filter.
    hidden_state : torch.Tensor or tuple of two torch.Tensor, default None
        Hidden state coming from the previous recurrent cell. If none is
        specified, the hidden state is initialized as zero.
    debug_loss : bool, default False
        Debugging flag, which makes the method also return an array of the
        optimization loss.

    Returns
    -------
    mask : numpy.Array
        Current mask filter, after the performed optimization step.

    if debug_loss is True:

    loss : float
        Current loss value of the mask filter optimization.
    &#39;&#39;&#39;
    # Get the model&#39;s output for the masked input data
    new_output = self.model((mask * data).unsqueeze(0).unsqueeze(0), hidden_state=hidden_state)
    # Calculate the loss function
    # • Minimize the number of activated mask filter units (occluded features)
    # • Maximize the change made to the output
    loss = l1_coeff * torch.mean(torch.abs(1 - mask)) + 1 - (ref_output - new_output).pow(2)
    # Backpropagate the loss function and run an optimization step (update the mask filter)
    loss.backward(retain_graph=True)
    mask.grad = du.deep_learning.change_grad((-1) * mask.grad, mask.data)
    mask.data = mask.data + mask.grad
    # Make sure that the mask has values either 0 or 1
    mask.data.clamp_(0, 1)
    mask.data.round_()
    if debug_loss:
        return mask, loss.item()
    else:
        return mask</code></pre>
</details>
</dd>
<dt id="model_interpreter.model_interpreter.ModelInterpreter.shap_values_df"><code class="name flex">
<span>def <span class="ident">shap_values_df</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a dataframe that contains both the original data used in the
interpretation of the model and the resulting SHAP values.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_n_shap_df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataframe that contains both the original data used in the
interpretation of the model and the resulting SHAP values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shap_values_df(self):
    &#39;&#39;&#39;Create a dataframe that contains both the original data used in the
    interpretation of the model and the resulting SHAP values.

    Returns
    -------
    data_n_shap_df : pandas.DataFrame
        Dataframe that contains both the original data used in the
        interpretation of the model and the resulting SHAP values.&#39;&#39;&#39;
    # [TODO] Add option to handle pre-calculated SHAP values
    # (pre-defined data and SHAP values, outside of the Model Interpreter)
    # Join the original data and the features&#39; SHAP values
    data_n_shap = np.concatenate([self.test_data.numpy(), self.test_labels.unsqueeze(2).numpy(), self.feat_scores], axis=2)
    # Reshape into a 2D format
    data_n_shap = data_n_shap.reshape(-1, data_n_shap.shape[-1])
    # Remove padding samples
    data_n_shap = data_n_shap[[self.padding_value not in row for row in data_n_shap]]
    # Define the column names list
    shap_column_names = [f&#39;{feature}_shap&#39; for feature in self.feat_names]
    column_names = ([self.id_column_name] + [self.inst_column_name] + self.feat_names
                    + [self.label_column_name] + shap_column_names)
    # Create the dataframe
    data_n_shap_df = pd.DataFrame(data=data_n_shap, columns=column_names)
    return data_n_shap_df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="model_interpreter" href="index.html">model_interpreter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="model_interpreter.model_interpreter.calc_instance_score" href="#model_interpreter.model_interpreter.calc_instance_score">calc_instance_score</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="model_interpreter.model_interpreter.KernelFunction" href="#model_interpreter.model_interpreter.KernelFunction">KernelFunction</a></code></h4>
<ul class="">
<li><code><a title="model_interpreter.model_interpreter.KernelFunction.f" href="#model_interpreter.model_interpreter.KernelFunction.f">f</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="model_interpreter.model_interpreter.ModelInterpreter" href="#model_interpreter.model_interpreter.ModelInterpreter">ModelInterpreter</a></code></h4>
<ul class="">
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.create_bkgnd_test_sets" href="#model_interpreter.model_interpreter.ModelInterpreter.create_bkgnd_test_sets">create_bkgnd_test_sets</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.feature_importance" href="#model_interpreter.model_interpreter.ModelInterpreter.feature_importance">feature_importance</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.instance_importance" href="#model_interpreter.model_interpreter.ModelInterpreter.instance_importance">instance_importance</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.instance_importance_plot" href="#model_interpreter.model_interpreter.ModelInterpreter.instance_importance_plot">instance_importance_plot</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.interpret_model" href="#model_interpreter.model_interpreter.ModelInterpreter.interpret_model">interpret_model</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.mask_filter" href="#model_interpreter.model_interpreter.ModelInterpreter.mask_filter">mask_filter</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.mask_filter_step" href="#model_interpreter.model_interpreter.ModelInterpreter.mask_filter_step">mask_filter_step</a></code></li>
<li><code><a title="model_interpreter.model_interpreter.ModelInterpreter.shap_values_df" href="#model_interpreter.model_interpreter.ModelInterpreter.shap_values_df">shap_values_df</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>